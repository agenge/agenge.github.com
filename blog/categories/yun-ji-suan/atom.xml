<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[文章分类: 云计算 | TaurusHome]]></title>
  <link href="http://agenge.github.io/blog/categories/yun-ji-suan/atom.xml" rel="self"/>
  <link href="http://agenge.github.io/"/>
  <updated>2013-10-24T09:29:31+08:00</updated>
  <id>http://agenge.github.io/</id>
  <author>
    <name><![CDATA[agenge]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Keystone 源码安装与配置]]></title>
    <link href="http://agenge.github.io/blog/2013/10/24/the-keystone-with-source-installation-and-conf/"/>
    <updated>2013-10-24T09:02:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/10/24/the-keystone-with-source-installation-and-conf</id>
    <content type="html"><![CDATA[<h2>Keystone介绍</h2>

<p>什么是Keystone？
Keystone 作为OpenStack中身份认证服务，在OpenStack起到非常关键的作用。它主要负责身份认证，服务规则及令牌的作用，且实现了Identity API,供OpenStack其他各组件之间来进行身份验证。</p>

<h3>安装依赖包</h3>

<p><code>
apt-get install -y git python-dev sqlite3 libxml2-dev libxslt1-dev libsasl2-dev libsqlite3-dev libssl-dev libldap2-dev
</code></p>

<p><strong> 下载源码 </strong></p>

<p><code>
git clone https://github.com/openstack/keystone.git
git clone https://github.com/openstack/python-keystoneclient.git keystone/client
</code></p>

<p>安装keystone</p>

<p><code>
cd keystone
git checkout origin/stable/grizzly
pip install -r tools/pip-requires
python setup.py install
</code></p>

<p>安装客户端</p>

<p>```
cd client
git checkout -b origin/feature/keystone-v3
pip install -r requirements.txt
python setup.py install</p>

<p>cd ../
mkdir -p /etc/keystone
cp etc/keystone.conf.sample /etc/keystone/keystone.conf
cp etc/logging.conf.sample /etc/keystone/logging.conf
```</p>

<p><strong> 配置日志存放路径 </strong></p>

<p><code>
mkdir -p /var/log/keystone
touch /var/log/keystone/keystone.log
</code></p>

<p>数据库同步，即创建keystone相关的数据库表</p>

<p><code>
keystone-manage db_sync
</code></p>

<p>启动服务</p>

<p><code>
keystone-all -d &amp;
</code></p>

<!-- more -->


<h2>配置Keytone</h2>

<p>截止到现在，我们已经完成Keystone的安装，但现在还无法使用，因为没有租户、用户、密码、服务等。</p>

<p>为使用方便，先设置两个环境变量</p>

<p><code>
export OS_SERVICE_TOKEN=ADMIN
export SERVICE_ENDPOINT=http://192.168.30.150:35357/v2.0
</code></p>

<p>如果前面安装没问题的话，使用以下命令查看用户列表，默认是没有任何数据返回</p>

<p><code>
keystone user-list
</code></p>

<ol>
<li>创建租户</li>
</ol>


<p><code>
keystone tenant-create --name adminTenant --description "Admin Tenant" --enabled true
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |           Admin Tenant           |
|   enabled   |               True               |
|      id     | e36e42a5ed264317a7a5119b1f513e32 |
|     name    |           adminTenant            |
+-------------+----------------------------------+
</code>
需要记录 tenant id，在创建用户时需要关联，即将用户关联到哪个租户。</p>

<ol>
<li>创建用户</li>
</ol>


<p><code>
keystone user-create --tenant_id e36e42a5ed264317a7a5119b1f513e32 --name admin --pass openstack --enabled true
+----------+----------------------------------+
| Property |              Value               |
+----------+----------------------------------+
|  email   |                                  |
| enabled  |               True               |
|    id    | 8cc6ddbeab504e2b9e8bf30eff3d92b7 |
|   name   |              admin               |
| tenantId | e36e42a5ed264317a7a5119b1f513e32 |
+----------+----------------------------------+
</code></p>

<ol>
<li>创建角色</li>
</ol>


<p>创建一个角色名称为adminRole。请记住该命令生成的Role id，下面的关联用户及租户时需要用到</p>

<p><code>
keystone role-create --name adminRole
+----------+----------------------------------+
| Property |              Value               |
+----------+----------------------------------+
|    id    | a00bf7b7fe4e4746bac0fd69778f3dfa |
|   name   |            adminRole             |
+----------+----------------------------------+
</code></p>

<p>截止到目前，已经分别创建 Tenant、User、Role，分别是：</p>

<p>Tenant ID:  e36e42a5ed264317a7a5119b1f513e32
User ID:    8cc6ddbeab504e2b9e8bf30eff3d92b7
Role ID:    a00bf7b7fe4e4746bac0fd69778f3dfa</p>

<p>现在将它们三者关联到一起</p>

<p><code>
keystone user-role-add --user-id 8cc6ddbeab504e2b9e8bf30eff3d92b7 \
 --tenant-id e36e42a5ed264317a7a5119b1f513e32 \
 --role-id a00bf7b7fe4e4746bac0fd69778f3dfa
</code></p>

<h2>Keytone测试</h2>

<h3>通过 Keystone 获取 Token</h3>

<p>访问Keystone 需要4个参数：TenantName Username Password 申请URL，其中URL可以是：</p>

<pre><code>http://192.168.30.150:35357/v2.0/tokens 或 http://192.168.30.150:5000/v2.0/tokens
</code></pre>

<p><code>
curl -d '{"auth": {"tenantName": "adminTenant", "passwordCredentials":{"username": "admin", "password": "openstack"}}}' -H "Content-type: application/json" http://192.168.30.150:35357/v2.0/tokens | python -mjson.tool
</code>
将会返回以下类似信息</p>

<p>```
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</p>

<pre><code>                             Dload  Upload   Total   Spent    Left  Speed
</code></pre>

<p>100   676  100   567  100   109   6290   1209 &mdash;:&mdash;:&mdash; &mdash;:&mdash;:&mdash; &mdash;:&mdash;:&mdash;  6517
{</p>

<pre><code>"access": {
    "metadata": {
        "is_admin": 0, 
        "roles": [
            "9fe2ff9ee4384b1894a90878d3e92bab", 
            "a00bf7b7fe4e4746bac0fd69778f3dfa"
        ]
    }, 
    "serviceCatalog": [], 
    "token": {
        "expires": "2013-10-16T09:03:21Z", 
        "id": "7c76f8315f6e42d6a05b0ed726bc3441", 
        "issued_at": "2013-10-15T09:03:21.809471", 
        "tenant": {
            "description": "Admin Tenant", 
            "enabled": true, 
            "id": "e36e42a5ed264317a7a5119b1f513e32", 
            "name": "adminTenant"
        }
    }, 
    "user": {
        "id": "8cc6ddbeab504e2b9e8bf30eff3d92b7", 
        "name": "admin", 
        "roles": [
            {
                "name": "_member_"
            }, 
            {
                "name": "adminRole"
            }
        ], 
        "roles_links": [], 
        "username": "admin"
    }
}
</code></pre>

<p>}
```</p>

<p>从上述返回结果能看到正常返回 token。更详细的操作请参考<a href="http://agenge.com/blog/2013/10/17/use-the-curl-operation-swift/">使用Curl操作OpenStack Swift</a></p>

<h2>错误汇总</h2>

<p>```
Traceback (most recent call last):
   File &ldquo;/usr/bin/easy_install&rdquo;, line 5, in <module></p>

<pre><code> from pkg_resources import load_entry_point ImportError: No module named pkg_resources raid:/home/linyoujushi# easy_install genshi Traceback (most recent call last):
</code></pre>

<p>```</p>

<p>解决办法：</p>

<p>这是由于我们没有安装setuptools或者没有装好，我们只需要安装这个软件就行了。安装方法：</p>

<p><code>
wget http://peak.telecommunity.com/dist/ez_setup.py
python ez_setup.py
</code></p>

<p>或者，我们装的setuptools工具太老，我们升级一下：</p>

<p><code>
sudo python ./ez_setup.py -U setuptools
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Curl操作OpenStack Swift]]></title>
    <link href="http://agenge.github.io/blog/2013/10/17/use-the-curl-operation-swift/"/>
    <updated>2013-10-17T09:51:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/10/17/use-the-curl-operation-swift</id>
    <content type="html"><![CDATA[<p>提示：以下操作均是使用的 swift tempauth认证机制。</p>

<ul>
<li>获取 Token</li>
</ul>


<p>```</p>

<pre><code>curl -k -v -H 'X-Storage-User: admin:admin' -H 'X-Storage-Pass: admin' http://192.168.30.150:8080/auth/v1.0
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
* About to connect() to 192.168.30.150 port 8080 (#0)
*   Trying 192.168.30.150&hellip; connected</p>

<blockquote><p>GET /auth/v1.0 HTTP/1.1
User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
Host: 192.168.30.150:8080
Accept: <em>/</em>
X-Storage-User: admin:admin
X-Storage-Pass: admin</p>

<p>&lt; HTTP/1.1 200 OK
&lt; X-Storage-Url: <a href="http://192.168.30.150:8080/v1/AUTH_admin">http://192.168.30.150:8080/v1/AUTH_admin</a>
&lt; X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Type: text/html; charset=UTF-8
&lt; X-Storage-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Length: 0
&lt; Date: Tue, 15 Oct 2013 01:49:59 GMT
&lt;
* Connection #0 to host 192.168.30.150 left intact
* Closing connection #0
```</p></blockquote>

<ul>
<li>Account操作</li>
</ul>


<p>```</p>

<pre><code>curl -k -v -X HEAD -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
* About to connect() to 192.168.30.150 port 8080 (#0)
*   Trying 192.168.30.150&hellip; connected</p>

<blockquote><p>HEAD /v1/AUTH_admin HTTP/1.1
User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
Host: 192.168.30.150:8080
Accept: <em>/</em>
X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5</p>

<p>&lt; HTTP/1.1 204 No Content
&lt; Content-Length: 0
&lt; Accept-Ranges: bytes
&lt; X-Timestamp: 1381806617.24083
&lt; X-Account-Bytes-Used: 0
&lt; X-Account-Container-Count: 1
&lt; Content-Type: text/plain; charset=utf-8
&lt; X-Account-Object-Count: 0
&lt; Date: Tue, 15 Oct 2013 05:17:23 GMT
&lt;
* Connection #0 to host 192.168.30.150 left intact
* Closing connection #0
```</p></blockquote>

<ul>
<li><p>Container操作</p>

<ul>
<li>列出 Contailner</li>
</ul>
</li>
</ul>


<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin
</code>
 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 5
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 1
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:20:11 GMT</p>

<p>test
```
 最后一行的test就是查询出来的内容。</p>

<ul>
<li>创建 Container</li>
</ul>


<p><code>
curl -i -X PUT -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile
</code></p>

<p>   如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 201 Created
Content-Length: 0
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:22:01 GMT
</code></p>

<p>  我们再来查询一次看是否成功：</p>

<p>  <!-- more --></p>

<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin
</code></p>

<p>  如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 12
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:23:18 GMT</p>

<p>myfile
test
```</p>

<ul>
<li> 只列出部分 Container</li>
</ul>


<p>  很多时候 Container 会有很多个，Swift 默认会列出前10000个，但如果我们只看最前面几个，该怎么办？ 以下示例只显示最前面一个 Container</p>

<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin?limit=1
</code></p>

<p> 结果：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 7
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:24:36 GMT</p>

<p>myfile
```</p>

<p>  那如果要列出最后几个 Container 又怎么办呢？ 加一个 marker即可，以下示例列出 myfile之后的一个Container</p>

<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin?marker=myfile\&amp;limit=1
</code></p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 5
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:28:53 GMT</p>

<p>test
```</p>

<ul>
<li>格式化输出 Container</li>
</ul>


<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin?format=json
</code></p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 86
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: application/json; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:29:58 GMT</p>

<p>[{&ldquo;count&rdquo;: 0, &ldquo;bytes&rdquo;: 0, &ldquo;name&rdquo;: &ldquo;myfile&rdquo;}, {&ldquo;count&rdquo;: 0, &ldquo;bytes&rdquo;: 0, &ldquo;name&rdquo;: &ldquo;test&rdquo;}]
```</p>

<p>  除了JSON格式，还可以格式化XML，只需要将json改成xml 即可。</p>

<ul>
<li>查看 Container metadata</li>
</ul>


<p><code>
curl -i -X HEAD -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/test
</code></p>

<p>  如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 204 No Content
Content-Length: 0
X-Container-Object-Count: 0
Accept-Ranges: bytes
X-Timestamp: 1381806903.70007
X-Container-Bytes-Used: 0
Content-Type: text/plain; charset=utf-8
Date: Tue, 15 Oct 2013 05:32:06 GMT
</code></p>

<ul>
<li>删除 Container</li>
</ul>


<p><code>
curl -i -X DELETE -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/mytest
</code></p>

<ul>
<li><p>Object操作</p>

<ul>
<li>创建 Object</li>
</ul>
</li>
</ul>


<p><code>
curl -k -i -X PUT -T "apache-tomcat-6.0.36.tgz" -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile/apache-tomcat-6.0.36.tgz
</code></p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 100 Continue</p>

<p>HTTP/1.1 201 Created
Last-Modified: Tue, 15 Oct 2013 05:39:07 GMT
Content-Length: 0
Etag: 3dde098fd0b3a08d3f2867e4a95591ba
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:39:08 GMT
```</p>

<ul>
<li>列出  Object</li>
</ul>


<p>```</p>

<pre><code>curl -k -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile
</code></pre>

<p>```</p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 25
X-Container-Object-Count: 1
Accept-Ranges: bytes
X-Timestamp: 1381814521.71796
X-Container-Bytes-Used: 6780936
Content-Type: text/plain; charset=utf-8
Date: Tue, 15 Oct 2013 05:40:43 GMT</p>

<p>apache-tomcat-6.0.36.tgz
```</p>

<p>另外 Object和 Container一样可以通过加参数来限制查询，具体示例可参考 Container操作。</p>

<ul>
<li>下载 Object</li>
</ul>


<p>```</p>

<pre><code>curl -k -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile/apache-tomcat-6.0.36.tgz &gt; apache-tomcat-6.0.36.tgz
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</p>

<pre><code>                             Dload  Upload   Total   Spent    Left  Speed
</code></pre>

<p>100 6622k  100 6622k    0     0  32.8M      0 &mdash;:&mdash;:&mdash; &mdash;:&mdash;:&mdash; &mdash;:&mdash;:&mdash; 33.1M
```</p>

<ul>
<li>Copy Object</li>
</ul>


<p><code>
curl -k -i -X PUT -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' \
 -H 'X-Copy-From: /myfile/apache-tomcat-6.0.36.tgz' \
 -H 'Content-Length:0' http://192.168.30.150:8080/v1/AUTH_admin/test/apache-tomcat-6.0.36.tgz
</code></p>

<p>将/myfile/apache-tomcat-6.0.36.tgz 拷贝到 /test/apache-tomcat-6.0.36.tgz,如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 201 Created
Content-Length: 0
X-Copied-From-Last-Modified: Tue, 15 Oct 2013 05:39:07 GMT
X-Copied-From: myfile/apache-tomcat-6.0.36.tgz
Last-Modified: Tue, 15 Oct 2013 05:47:52 GMT
Etag: 3dde098fd0b3a08d3f2867e4a95591ba
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:47:52 GMT
</code></p>

<ul>
<li>删除 Object</li>
</ul>


<p>```</p>

<pre><code>curl -k -i -X DELETE -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/test/apache-tomcat-6.0.36.tgz
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 204 No Content
Content-Length: 0
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:50:49 GMT
</code>
 通过之前的GET就能验证是否成功删除，此处略过。</p>

<ul>
<li>设置 Object Metadata</li>
</ul>


<p><code>
curl -k -i -X POST -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' \
-H 'X-Object-Meta-Breed: apache tomcat 6.0.36' \
 http://192.168.30.150:8080/v1/AUTH_admin/myfile/apache-tomcat-6.0.36.tgz
</code></p>

<p>如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 202 Accepted
Content-Length: 76
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:54:09 GMT
</code></p>

<p>通过之前的HEAD，就能查看到刚才添加的元数据</p>

<p><code>
HTTP/1.1 200 OK
Content-Length: 6780936
X-Object-Meta-Breed: apache tomcat 6.0.36
Accept-Ranges: bytes
Last-Modified: Tue, 15 Oct 2013 05:54:08 GMT
Etag: 3dde098fd0b3a08d3f2867e4a95591ba
X-Timestamp: 1381816448.74507
Content-Type: application/x-tar
Date: Tue, 15 Oct 2013 05:55:53 GMT
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStack Swift安装与配置]]></title>
    <link href="http://agenge.github.io/blog/2013/10/15/openstack-swift-install/"/>
    <updated>2013-10-15T14:00:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/10/15/openstack-swift-install</id>
    <content type="html"><![CDATA[<h2>准备环境</h2>

<p><code>
192.168.30.150  proxy server
192.168.30.151  storage server
192.168.30.152  storage server
</code></p>

<h2>网络配置</h2>

<p><strong> Proxy 代理节点网络(单网卡)  </strong></p>

<p>```
auto lo
iface lo inet loopback</p>

<h1>The primary network interface</h1>

<p>auto eth0
iface eth0 inet static
address 192.168.30.150
netmask 255.255.255.0
gateway 192.168.30.1
network 192.168.30.0
broadcast 192.168.30.255
dns-nameservers 218.201.4.3
```</p>

<p><strong> 存储节点网络(单网卡)  </strong>
存储节点1：</p>

<p>```
auto lo
iface lo inet loopback</p>

<h1>The primary network interface</h1>

<p>auto eth0
iface eth0 inet static
address 192.168.30.151
netmask 255.255.255.0
gateway 192.168.30.1
network 192.168.30.0
broadcast 192.168.30.255
dns-nameservers 218.201.4.3
```</p>

<p>存储节点2：</p>

<p>```
auto lo
iface lo inet loopback</p>

<h1>The primary network interface</h1>

<p>auto eth0
iface eth0 inet static
address 192.168.30.152
netmask 255.255.255.0
gateway 192.168.30.1
network 192.168.30.0
broadcast 192.168.30.255
dns-nameservers 218.201.4.3
```</p>

<h2>安装公共组件</h2>

<p>以下操作在所有节点全部安装：</p>

<h3>添加源</h3>

<p><code>
cat &gt; /etc/apt/sources.list.d/grizzly.list &lt;&lt; _END_
deb http://ubuntu-cloud.archive.canonical.com/ubuntu precise-updates/grizzly main
deb  http://ubuntu-cloud.archive.canonical.com/ubuntu precise-proposed/grizzly main
_END_
</code></p>

<p>更新源</p>

<p><code>
sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 5EDB1B62EC4926EA
apt-get update
apt-get upgrade
apt-get install ubuntu-cloud-keyring
</code></p>

<!-- more -->


<h2>安装 Swift</h2>

<p><code>
os_swift="python-swift swift swift-proxy swift-account swift-container swift-object python-memcache xfsprogs"
os_keystone="python-keystone python-keystoneclient"
apt-get install -y $os_swift $os_keystone
</code></p>

<p>安装之后需要手工创建 swift相关配置文件:</p>

<p><code>
mkdir /etc/swift
touch /etc/swift/swift.conf
touch /etc/swift/proxy-server.conf
chown -R swift:swift /etc/swift
</code></p>

<p>添加 swift.conf内容：</p>

<p>```
cat > /etc/swift/swift.conf &lt;&lt; <em>END</em>
[swift-hash]</p>

<h1>od -t x8 -N 8 -A n &lt; /dev/random</h1>

<h1>The above command can be used to generate random a string.</h1>

<p>swift_hash_path_suffix = 50ea1ddb6e88b991
<em>END</em>
```</p>

<p>将以下内容添加到 /etc/swift/proxy-server.conf内容：</p>

<p>```
[DEFAULT]
bind_port = 8080
bind_ip = 0.0.0.0
user = swift
swift_dir = /etc/swift</p>

<p>log_facility = LOG_LOCAL0
log_level = DEBUG</p>

<p>[pipeline:main]
pipeline = catch_errors healthcheck cache authtoken keystoneauth container-quotas account-quotas proxy-server</p>

<p>[app:proxy-server]
use = egg:swift#proxy
allow_account_management = true
account_autocreate = true</p>

<p>[filter:keystoneauth]
use = egg:swift#keystoneauth
operator_roles = Member,admin</p>

<p>[filter:authtoken]
paste.filter_factory = keystone.middleware.auth_token:filter_factory
service_protocol = http
service_port = 5000
service_host = 192.168.30.150
auth_port = 35357
auth_host = 192.168.30.150
auth_protocol = http
admin_tenant_name = service
admin_user = swift
admin_password = password
signing_dir = /etc/swift</p>

<p>[filter:cache]
use = egg:swift#memcache
set log_name = cache
memcache_servers = 192.168.30.150:11211</p>

<p>[filter:catch_errors]
use = egg:swift#catch_errors</p>

<p>[filter:healthcheck]
use = egg:swift#healthcheck</p>

<p>[filter:proxy-logging]
use = egg:swift#proxy_logging</p>

<p>[filter:ratelimit]
use = egg:swift#ratelimit
[filter:container-quotas]
use = egg:swift#container_quotas</p>

<p>[filter:account-quotas]
use = egg:swift#account_quotas
```</p>

<p>如果不使用 Keystone 认证，请使用以下的配置文件：</p>

<p>```
[DEFAULT]
bind_port = 8080
bind_ip = 192.168.30.150
user = swift</p>

<p>[pipeline:main]
pipeline = healthcheck cache tempauth proxy-server</p>

<p>[app:proxy-server]
use = egg:swift#proxy
allow_account_management = true
account_autocreate = true</p>

<p>[filter:tempauth]
use = egg:swift#tempauth
user_admin_admin = admin .admin .reseller_admin
user_test_tester = testing .admin
user_test2_tester2 = testing2 .admin
user_test_tester3 = testing3</p>

<p>[filter:healthcheck]
use = egg:swift#healthcheck</p>

<p>[filter:cache]
use = egg:swift#memcache
memcache_servers = 192.168.30.150:11211
```</p>

<p>格式： user<em><login1></em><login2> = <password> <privileges>
登录的时候就是：</p>

<p><code>
login = admin:admin
password = admin
privileges = .admin .reseller_admin
</code></p>

<p>配置rsyslog</p>

<p><code>
echo "local0.*    /var/log/swift/proxy-server.log" &gt;&gt; /etc/rsyslog.conf
mkdir /var/log/swift
</code></p>

<p>配置 环 Ring</p>

<p><code>
cd /etc/swift
sudo swift-ring-builder account.builder create 6 2 1
sudo swift-ring-builder container.builder create 6 2 1
sudo swift-ring-builder object.builder create 6 2 1
</code>
说明</p>

<ul>
<li>第一个数字：6表示分区(环)将被处理为2<sup>6th</sup>，即使用2的6次方个分区，创建完之后应有 64个分区</li>
<li>第二个数字：每个存储对象保存2份，即创建2个副本；由于偶只有两台storage，故只写2</li>
<li>第三个数字：1表示限制分区数据转移的时间，此处表示1小时，即分区被连续移动两次之间的最小时间间隔</li>
</ul>


<p>添加设备
添加新设备到Ring上，但add操作不会分配partitions到新的设备上，只有运行“rebalance”命令后才会进行分区的分配，所以这种方式可以有这种优势： 允许一次添加多个设备，只执行一次rebalance就可以了，以下操作步骤：</p>

<p>```
sudo swift-ring-builder account.builder add z1-192.168.30.151:6002/sdb1 100
sudo swift-ring-builder account.builder add z2-192.168.30.152:6002/sdb1 100</p>

<p>sudo swift-ring-builder container.builder add z1-192.168.30.151:6001/sdb1 100
sudo swift-ring-builder container.builder add z2-192.168.30.152:6001/sdb1 100</p>

<p>sudo swift-ring-builder object.builder add z1-192.168.30.151:6000/sdb1 100
sudo swift-ring-builder object.builder add z2-192.168.30.152:6000/sdb1 100
```</p>

<p>查看 Ring信息
可通过以下命令查到到Ring和Ring中的设备信息：
* 查询account信息：</p>

<pre><code>    swift-ring-builder account.builder
</code></pre>

<ul>
<li><p>查询container信息：</p>

<pre><code>  swift-ring-builder container.builder
</code></pre></li>
<li><p>查询object信息</p>

<pre><code>  swift-ring-builder object.builder
</code></pre></li>
<li><p>生成 Ring
如果确认一切之后，最终还要生成Ring，来进行分区的分配，即之前提到的rebalance：</p></li>
</ul>


<p><code>
sudo swift-ring-builder account.builder rebalance
sudo swift-ring-builder container.builder rebalance
sudo swift-ring-builder object.builder rebalance
</code></p>

<p>设置权限</p>

<p><code>
chown -R swift:swift /etc/swift
chown -R swift:swift /var/cache/swift
</code></p>

<hr />

<h2>存储节点安装与配置</h2>

<p>添加设备：
先创建分区，另外一定要是 XFS文件系统</p>

<p><code>
mkdir -p /srv/node/sdb1
chown -R swift:swift /srv/node/
mkfs.xfs -i size=1024 /dev/sdb1 -f
echo "/dev/sdb1 /srv/node/sdb1 xfs noatime,nodiratime,nobarrier,logbufs=8 0 0" &gt;&gt; /etc/fstab
mount /srv/node/sdb1  
</code></p>

<p>设置 rsyncd.conf</p>

<p>```
uid = swift
gid = swift</p>

<p>log file = /var/log/rsyncd.log
pid file = /var/run/rsyncd.pid
address = 192.168.30.151</p>

<p>[account]
max_connections = 2
path = /srv/node/
read only = false
lock file = /var/lock/account.lock</p>

<p>[container]
max_connections = 2
path = /srv/node/
read only = false
lock file = /var/lock/container.lock</p>

<p>[object]
max_connections = 2
path = /srv/node/
read only = false
lock file = /var/lock/object.lock
```</p>

<p>设置 rsync开机自启动</p>

<pre><code>sudo sed -i 's/RSYNC_ENABLE=false/RSYNC_ENABLE=true/g' /etc/default/rsync
</code></pre>

<p>启动 rsync服务</p>

<pre><code>sudo service rsync start
</code></pre>

<p>创建/etc/account-server.conf：</p>

<p>```
[DEFAULT]
bind_ip = 0.0.0.0
bind_port = 6002
workers = 1
user = swift
swift_dir = /etc/swift
devices = /srv/node</p>

<p>[pipeline:main]
pipeline = account-server</p>

<p>[app:account-server]
use = egg:swift#account</p>

<p>[account-replicator]</p>

<p>[account-auditor]</p>

<p>[account-reaper]</p>

<p>```</p>

<p>创建/etc/container-server.conf</p>

<p>```
[DEFAULT]
bind_ip = 0.0.0.0
bind_port = 6001
workers = 1
user = swift
swift_dir = /etc/swift
devices = /srv/node</p>

<p>[pipeline:main]
pipeline = container-server</p>

<p>[app:container-server]
use = egg:swift#container</p>

<p>[container-replicator]</p>

<p>[container-updater]</p>

<p>[container-auditor]</p>

<p>[container-sync]
```</p>

<p>创建/etc/object-server.conf</p>

<p>```
[DEFAULT]
bind_ip = 0.0.0.0
bind_port = 6000
workers = 1
user = swift
swift_dir = /etc/swift
devices = /srv/node</p>

<p>[pipeline:main]
pipeline = recon object-server</p>

<p>[app:object-server]
use = egg:swift#object</p>

<p>[filter:recon]
use = egg:swift#recon
recon_cache_path = /var/cache/swift</p>

<p>[object-replicator]</p>

<p>[object-updater]</p>

<p>[object-auditor]
```</p>

<h3>重启服务</h3>

<p>在所有存储节点重启以下服务：</p>

<p><code>
sudo swift-init object-server start
sudo swift-init object-replicator start
sudo swift-init object-updater start
sudo swift-init object-auditor start
sudo swift-init container-server start
sudo swift-init container-replicator start
sudo swift-init container-updater start
sudo swift-init container-auditor start
sudo swift-init account-server start
sudo swift-init account-replicator start
sudo swift-init account-auditor start
</code></p>

<p>在代理节点启动以下服务：</p>

<p><code>
sudo swift-init all restart
</code></p>

<h2>Swift操作</h2>

<p>获得 X-Storage-Url 和 X-Auth-Token:</p>

<pre><code>curl -k -v -H 'X-Storage-User: admin:admin' -H 'X-Storage-Pass: admin' http://192.168.30.150:8080/auth/v1.0
</code></pre>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
* About to connect() to 192.168.30.150 port 8080 (#0)
*   Trying 192.168.30.150&hellip; connected</p>

<blockquote><p>GET /auth/v1.0 HTTP/1.1
User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
Host: 192.168.30.150:8080
Accept: <em>/</em>
X-Storage-User: admin:admin
X-Storage-Pass: admin</p>

<p>&lt; HTTP/1.1 200 OK
&lt; X-Storage-Url: <a href="http://192.168.30.150:8080/v1/AUTH_admin">http://192.168.30.150:8080/v1/AUTH_admin</a>
&lt; X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Type: text/html; charset=UTF-8
&lt; X-Storage-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Length: 0
&lt; Date: Tue, 15 Oct 2013 01:49:59 GMT
&lt;
* Connection #0 to host 192.168.30.150 left intact
* Closing connection #0
```</p></blockquote>

<p>检查账号</p>

<pre><code>    curl -k -v -H 'X-Auth-Token: &lt;token-from-x-auth-token-above&gt;' &lt;url-from-xstorage-url-above&gt;  
</code></pre>

<p>这里的token-from-x-auth-token-above 就是上面输出的 AUTH_tk8a85916d63b14c568a4633b7920623c5，url-from-xstorage-url-above对应：<a href="http://192.168.30.150:8080/v1/AUTH_admin">http://192.168.30.150:8080/v1/AUTH_admin</a></p>

<p>检测 swift 命令是否工作正常</p>

<pre><code>    swift -A http://192.168.30.150:8080/auth/v1.0 -U admin:admin -K admin stat
</code></pre>

<p>正常输出类似以下信息：</p>

<p>```
   Account: AUTH_admin
Containers: 0
   Objects: 0</p>

<pre><code> Bytes: 0
</code></pre>

<p>Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
Content-Type: text/plain; charset=utf-8
```</p>

<p>上传</p>

<pre><code>swift -A http://192.168.30.150:8080/auth/v1.0 -U admin:admin -K admin upload test apache-tomcat-6.0.36.tar.gz
</code></pre>

<p>删除</p>

<pre><code>swift -A http://192.168.30.150:8080/auth/v1.0 -U admin:admin -K admin delete test apache-tomcat-6.0.36.tar.gz
</code></pre>

<h2>排错思路</h2>

<ol>
<li>直接看控制台打印的日志</li>
<li>检查配置文件是否正确</li>
<li>通过观察日志，例如/var/log/syslog</li>
<li>修改配置文件之后，需要重启对应的服务</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[制作OpenStack Windows Server 2008 镜像]]></title>
    <link href="http://agenge.github.io/blog/2013/07/24/make_openstack-windows2008-image/"/>
    <updated>2013-07-24T00:00:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/07/24/make_openstack-windows2008-image</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>对于OpenStack中，制作一个Windows 的镜像让很多新手极为烦恼，偶有幸成功制作，
不敢私藏，故与大家分享小小心得。上次与大家介绍过 <a href="http://agenge.com/cloud-computing/make_openstack-centos-image.html">制作OpenStack CentOS 6.3 镜像</a></p>

<p>本次主要是记录如何制作一个Windows Server 2008的镜像，请看操作：</p>

<ol>
<li>下载Virtio总线驱动</li>
</ol>


<p> 由于OpenStack只支持Virtio总线的磁盘，所以我们需要在安装之前下载virtio驱动：</p>

<pre><code>    wget http://alt.fedoraproject.org/pub/alt/virtio-win/latest/images/virtio-win-0.1-59.iso
</code></pre>

<ol>
<li>准备一个Windows Server 2008的ISO文件。</li>
</ol>


<p> 除了Virtio总线驱动，您还需要准备一个Windows Server 2008的ISO，为安装操作系统做准备。
3. 创建虚拟磁盘文件：</p>

<pre><code>    qemu-img create -f qcow2 winserver2008.img 20G
</code></pre>

<p> 对于虚拟磁盘文件的各种磁盘格式区别与对比，可以参考 <a href="http://blog.prajnagarden.com/?p=248">qcow2、raw、vmdk等镜像格式</a></p>

<ol>
<li><p>创建虚拟机，使用kvm或virt-install均可，本次安装使用的virt-install</p>

<pre><code> virt-install --connect qemu:///system -n winserver2008 --vcpus=1 -r 2048 \
   --disk path=/path/to/winserver2008.img,size=60,format=qcow2,bus=virtio,cache=none \
   -c /path/iso/windows_server_2008.iso \
   --vnc --vncport=5909 --vnclisten=0.0.0.0  \
   --os-type windows --os-variant=win2k8 --accelerate \
   --network=bridge:br0,model=virtio  \
   --disk path=/path/to/win_driver/virtio-win-0.1-59.iso,device=cdrom,perms=ro&lt;br /&gt;
</code></pre></li>
</ol>


<p> 以上参数有点多，不过这里不一一解释，后期偶会专门写一篇介绍KVM相关知识点，这里只是描述几个重要的参数：</p>

<pre><code>- -n  虚拟机的名称
- --disk  虚拟磁盘存放的路径，即第一步qemu-img创建的虚拟磁盘。&lt;/span&gt;&lt;/li&gt;
- -c  ISO的路径 &lt;/span&gt;&lt;/li&gt;
- --vncport  VNC连接端口，后面会用到，这里是5909，且必须是未使用的端口。&lt;/span&gt;&lt;/li&gt;
- --network   这个地方偶使用的是一个叫 br0 的网桥，所以你的系统必须保证有br0这个网桥。&lt;/span&gt;&lt;/li&gt;
</code></pre>

<!-- more -->


<p></p>

<p> 使用VNC 客户端连接，例如192.168.30.211:9 
 <img src="/images/2013/07/01.png"></p>

<p> 连接成功之后，和常规安装操作系统没有任何区别，但在分区时会提示找到磁盘文件，如图：</p>

<p> <img src="/images/2013/07/02.png"></p>

<p> 点击“<b>加载驱动程序</b>”，并按下图选择对应的驱动：</p>

<p> <img src="/images/2013/07/03.png"></p>

<p> 点击“确定”，如果WIN8驱动找不到磁盘，重新选择WIN7即可。然后再点击“下一步”：</p>

<p> <img src="/images/2013/07/04.png"></p>

<p> 安装之后并关机，进入下一步操作。</p>

<ol>
<li>上传镜像</li>
</ol>


<p> 最后一步就是要将刚才的虚拟磁盘文件上传到云平台中心:</p>

<pre><code>    glance image-create --name Win-2008-x86_64-cloud --is-public true --container-format ovf --disk-format qcow2 &lt; /home/agen/winserver2008.img
</code></pre>

<p> 通过以上的步骤，希望新手能够成功制作一份完美的镜像文件，如果在制作过程中有任何疑问，请留言，最好是邮件，偶在有时间的情况下肯定会第一时间解答。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[制作OpenStack CentOS 6.3 镜像]]></title>
    <link href="http://agenge.github.io/blog/2013/07/20/make_openstack-centos-image/"/>
    <updated>2013-07-20T00:00:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/07/20/make_openstack-centos-image</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>距离上次写文章已经N天，即对不住各位，更对不住自己，今天将教大家如何制作
OpenStack CentOS 6.3 镜像，费话不多说，咱就开始干活吧。</p>

<ol>
<li><p>准备一个镜像文件，即ISO文件，本示例所使用的为：</p>

<pre><code> CentOS-6.3-i386-minimal.iso
</code></pre></li>
</ol>


<p> <em>注：无论您是内部测试环境还是生产环境，偶都强烈推荐使用64位操作系统。</em></p>

<ol>
<li><p>引导并安装系统</p>

<pre><code> virt-install -n CentOS63 -r 2048 --cpu host \
   -c /data/iso/CentOS-6.3-i386-minimal.iso \
   --disk path=/data/kvm_data/centos6.3-openstack.img,device=disk,bus=virtio,size=10,format=qcow2 \
   --vnc --vncport=5908 --vnclisten=0.0.0.0 -v \
   --network bridge=br0
</code></pre></li>
</ol>


<p> 这些参数的就请您先自行查找手册，后期有时间偶会补上关于KVM的相关实践手册。</p>

<ol>
<li>镜像相关设置（此处根据你的需求进行个性化定制，尽量保持简洁）：</li>
<li><p>分区全部给根分区，防火墙和SELinux禁止.</p>

<pre><code>     chkconfig iptables off
</code></pre></li>
</ol>


<p> 将/etc/selinux/config 中的 SELINUX=enforcing修改成 SELINUX=disabled
 * 修改分区表：</p>

<pre><code>        vi /etc/fstab
        # 将UUID=这一行注释，加入：
        LABEL=cec-rootfs                           / ext4 defaults&lt;b&gt; 0 0&lt;/b&gt;
</code></pre>

<ul>
<li><p>修改网络配置：</p>

<pre><code>     vi /etc/sysconfig/network-scripts/ifcfg-eth0
     #将HWADDR=这行删除或注释即可，并且设置成BOOTPROTO=dhcp
</code></pre></li>
<li><p>删除网络规则，因为Centos6之后70-persistent-net.rules这个文件会自动添加除eth0之外的其他网络接口，</p>

<pre><code>     rm -rf /etc/udev/rules.d/70-persistent-net.rules
</code></pre></li>
<li>还要把另外一个文件删除，不然上面这个文件还会自动创建滴：
         mv /lib/udev/write_net_rules{,.bak}</li>
<li><p>上传镜像</p>

<pre><code> glance image-create --name centos63Image --is-public true --container-format ovf --disk-format qcow2 &amp;lt; /home/agen/centos63.img
</code></pre></li>
</ul>


<p> 至此，所有操作已经完成，如果一切正常，你所创建的实例访问正常。如网络还存在问题，可能
和您的OpenStack网络设置有关，不过这已经超出本文的范畴。假如您对OpenStack的环境搭建不是很熟悉的话，建议您再多看看这篇文章：<a title="Openstack安装与部署(Folsom)" href="http://agenge.com/cloud-computing/openstack_install_with_deploy_for_folsom.html">Openstack安装与部署(Folsom)</a>。</p>
]]></content>
  </entry>
  
</feed>
