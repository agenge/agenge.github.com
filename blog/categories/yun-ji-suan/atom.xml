<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[文章分类: 云计算 | TaurusHome]]></title>
  <link href="http://agenge.github.io/blog/categories/yun-ji-suan/atom.xml" rel="self"/>
  <link href="http://agenge.github.io/"/>
  <updated>2013-11-18T00:06:36+08:00</updated>
  <id>http://agenge.github.io/</id>
  <author>
    <name><![CDATA[agenge]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Centos 6.X 安装KVM与安装实例]]></title>
    <link href="http://agenge.github.io/blog/2013/11/15/centos-install-kvm-and-install-vm/"/>
    <updated>2013-11-15T21:58:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/11/15/centos-install-kvm-and-install-vm</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>虚拟化已经不是一个新鲜话题，不过仍然看到很多新手连KVM都没有入门，甚至是先接触OpenStack才遇到KVM，所以今天给各位新手提供一个安装教程。</p>

<h2>安装KVM依赖包</h2>

<p>目前绝大部分的CPU都支持Intel VT或AMD-V ，此处检查步骤略过。</p>

<p><code>
yum install -y bridge-utils kvm kmod-kvm qemu kvm-qemu-img virt-viewer virt-manager libvirt libvirt-python python-virtinst
</code></p>

<p>创建一个叫 br0 的网桥：
<code>
cd /etc/sysconfig/network-scripts/
cp ifcfg-eth0 ifcfg-br0
vi ifcfg-eth0
</code>
增加：
<code>
BRIDGE=br0
</code></p>

<p>将ifcfg-br0 修改为：
<code>
DEVICE="br0"
TYPE="Bridge"
</code></p>

<p>然后重启网络：
<code>
/etc/init.d/network restart
ifconfig br0
/etc/init.d/libvirtd restart
</code></p>

<p>经过上面的简单安装与设置之后，KVM就已经安装完成，但怎么通过命令行创建虚拟机呢？</p>

<h2>创建虚拟机</h2>

<!-- more -->


<p>创建一个磁盘文件
<code>
qemu-img create -f qcow2 /data/kvm_data/centos5.img 8g
</code></p>

<p>创建一个新的虚拟机
```</p>

<h1>-n 虚拟机名称</h1>

<h1>&mdash;vcpus 分配虚拟机CPU个数</h1>

<h1>-r 分配内存大小 默认为MB</h1>

<h1>-f 指定虚拟机的磁盘文件路径</h1>

<h1>-s 磁盘文件固定大小，例如-s 10 立即扩展到10G</h1>

<h1>-c 镜像文件位置</h1>

<h1>&mdash;vnc &mdash;vncport=590X &mdash;vnclisten=0.0.0.0  通过VNC连接安装操作系统</h1>

<h1>&mdash;os-type linux 安装一个linux虚拟机</h1>

<h1>&mdash;network=bridge:br0  网络连接方式：使用一个叫br0的网桥</h1>

<p>virt-install &mdash;connect qemu:///system -n test01 &mdash;vcpus=1 \
  -r 1024 &mdash;virt-type=kvm -f /data/kvm_data/centos5.img -s 10 \
  -c /data/iso/CentOS-5.5-x86_64-bin-DVD-1of2.iso \
  &mdash;vnc &mdash;vncport=5903 &mdash;vnclisten=0.0.0.0 &mdash;os-type linux &mdash;accelerate \
  &mdash;network=bridge:br0
```</p>

<p>自动安装CentOS 6.3
由于我在公司内部搭建了个无人值守服务，所幸可以直接安装使用：
<code>
virt-install --connect qemu:///system -n test03 --vcpus=1 \
  -r 2048 --virt-type=kvm -f /data/kvm_data/test03.img -s 20 \
  --vnc --vncport=5902 --vnclisten=0.0.0.0 \
  --os-type linux --accelerate \
  --network=bridge:br0 \
  -x ks=ftp://192.168.30.33/pub/ks/64/centos6.3/ks.cfg \
  --location ftp://192.168.30.33/pub/centos/6.3/x86_64/
</code></p>

<p>查看所有虚拟机(包括已经关闭的虚拟机)
<code>
virsh list --all
virsh destroy ID/NAME  关闭虚拟机
virsh start NAME   启动虚拟机
virsh console ID/NAME  控制台连接虚拟机
</code></p>

<p>安装虚拟机之后如何连接呢？ 有两种选择：VNC和Console，由于偶工作时不太喜欢图形界面，还是命令行吧
实现控制台连接需要在虚拟机做一些配置，如下：</p>

<ul>
<li>修改etc/grub.conf 添加“console=ttyS0
<code>
title CentOS (2.6.18-128.1.10.el5)
  root (hd0,0)
  kernel /boot/vmlinuz-2.6.18-128.1.10.el5 ro root=LABEL=/ console=ttyS0
  initrd /boot/initrd-2.6.18-128.1.10.el5.img
</code>
添加ttyS0到/etc/securetty</li>
</ul>


<p><code>
echo ttyS0 &gt;&gt; /etc/securetty
</code></p>

<ul>
<li>修改/etc/inittab添加下面这行：
<code>
S0:12345:respawn:/sbin/agetty ttyS0 115200
</code></li>
</ul>


<p>重启系统之后，使用语法为：
<code>
virsh console vm_name
</code></p>

<p>你还可以任何时刻退出控制台，快捷键为：ctrl+]</p>

<p>今天就暂时分享这些内容，下次有机会将分享一个关于Xen相关的教程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack安装与部署(Havana)]]></title>
    <link href="http://agenge.github.io/blog/2013/11/10/openstack-install-with-deploy-for-havana/"/>
    <updated>2013-11-10T13:19:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/11/10/openstack-install-with-deploy-for-havana</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>首先得说明一下，此教程是基于H版部署，由于时间关系，文章可能会有错误，如果有发现错误之处，请直接回复，感谢。</p>

<h2>环境准备</h2>

<h3>资源列表</h3>

<p> <img src="/images/2013/11/openstack-host-list.png" title="" ></p>

<h3>网络配置</h3>

<p>控制节点controller网络配置如下：</p>

<p>```</p>

<h1>Internal Network</h1>

<p>auto eth0
iface eth0 inet static
address 10.0.0.11
netmask 255.255.255.0</p>

<h1>External Netwok</h1>

<p>auto eth1
iface eth1 inet static
address 192.168.30.150
netmask 255.255.255.0
gateway 192.168.30.1
dns-nameservers 218.201.4.3
```</p>

<p>计算节点compute01网络配置如下：</p>

<p>```</p>

<h1>Internal Network</h1>

<p>auto eth0
iface eth0 inet static
address 10.0.0.13
netmask 255.255.255.0</p>

<h1>External Netwok</h1>

<p>auto eth1
iface eth1 inet static
address 192.168.30.151
netmask 255.255.255.0
gateway 192.168.30.1
dns-nameservers 218.201.4.3
```</p>

<p>设置hostname，在所有节点的/etc/hosts中加入：
<code>
10.0.0.11       controller
10.0.0.13       compute01
</code></p>

<p>重启网络
<code>
service networking restart
</code></p>

<p>IP转发
<code>
sed -i 's/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/' /etc/sysctl.conf
sysctl -p
</code></p>

<h3>时间同步</h3>

<p>安装NTP：</p>

<p><code>
apt-get install -y ntp
sed -i 's/server ntp.ubuntu.com/server ntp.ubuntu.com\nserver 127.127.1.0\nfudge 127.127.1.0 stratum 10/g' /etc/ntp.conf
sudo /etc/init.d/ntp restart
</code></p>

<p>其他节点的server都指向控制节点：10.0.0.11</p>

<h3>Mysql和rabbitmq安装</h3>

<p>在控制节点执行，安装过程中会提示输入几个密码，此处为了方便，密码统一设置为openstack (是不是应该打马赛克？)：</p>

<p>```
apt-get install -y mysql-server python-mysqldb
sed -i &rsquo;s/127.0.0.1/10.0.0.11/g' /etc/mysql/my.cnf
/etc/init.d/mysql restart</p>

<p>apt-get install -y rabbitmq-server
```</p>

<h3>添加Havana 仓库</h3>

<p>安装 Keyring
<code>
apt-get install ubuntu-cloud-keyring
</code></p>

<p>添加仓库源
<code>
echo "deb http://ubuntu-cloud.archive.canonical.com/ubuntu precise-updates/havana main" &gt;&gt; /etc/apt/sources.list.d/cloudarchive-havana.list
echo "deb-src http://ubuntu-cloud.archive.canonical.com/ubuntu precise-updates/havana main" &gt;&gt; /etc/apt/sources.list.d/cloudarchive-havana.list
</code></p>

<p>更新系统
<code>
apt-get update
apt-get dist-upgrade
</code>
如果遇到无法update，多半是网络运营商缓存问题导致的，这时使用代理搞定吧：
<code>
sudo apt-get -o Acquire::http::proxy="http://127.0.0.1:8087/" update
</code></p>

<!-- more -->


<h3>初始化数据库</h3>

<p>在控制节点执行，创建数据库，并设置：
<code>
mysql -uroot -p
</code></p>

<p>输入密码后执行以下SQL语句
```
CREATE DATABASE keystone;
CREATE DATABASE nova;
CREATE DATABASE cinder;
CREATE DATABASE glance;
CREATE DATABASE neutron;
CREATE DATABASE heat;
GRANT ALL ON neutron.<em> TO neutron@&lsquo;%&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;
GRANT ALL ON neutron.</em> TO neutron@&lsquo;10.0.0.11&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;
GRANT ALL ON keystone.* TO neutron@&lsquo;%&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;</p>

<p>GRANT ALL ON keystone.<em> TO keystone@&lsquo;%&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;
GRANT ALL ON keystone.</em> TO keystone@&lsquo;10.0.0.11&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;
GRANT ALL ON nova.<em> TO nova@&lsquo;%&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;
GRANT ALL ON nova.</em> TO nova@&lsquo;10.0.0.11&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;
GRANT ALL ON cinder.<em> TO cinder@&lsquo;%&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;
GRANT ALL ON cinder.</em> TO cinder@&lsquo;10.0.0.11&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;
GRANT ALL ON glance.<em> TO glance@&lsquo;%&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;
GRANT ALL ON glance.</em> TO glance@&lsquo;10.0.0.11&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;
GRANT ALL ON heat.<em> TO heat@&lsquo;%&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;
GRANT ALL ON heat.</em> TO heat@&lsquo;10.0.0.11&rsquo; IDENTIFIED BY &lsquo;openstack&rsquo;;</p>

<p>flush privileges;
```
需要注意的是以上的IP需要你自己根据实际情况而修改。</p>

<hr />

<h2>控制节点</h2>

<h3>Identity Service(Keystone)安装</h3>

<p>在控制节点安装认证服务keystone
<code>
apt-get install -y keystone python-keystone python-keystoneclient
</code></p>

<h4>Keystone配置</h4>

<p>keystone支持mysql、sqlite及LDAP，以下示例我们将使用Mysql来存储keystone认证信息。</p>

<p>在控制节点修改/etc/keystone/keystone.conf配置文件，注释第78行：</p>

<pre><code>connection = sqlite:////var/lib/keystone/keystone.db
</code></pre>

<p>加入：</p>

<pre><code>connection = mysql://keystone:openstack@10.0.0.11/keystone
</code></pre>

<p>重启keystone后，初始化数据库：</p>

<p><code>
keystone-manage db_sync
/etc/init.d/keystone restart
</code></p>

<p>配置openssl
在keystone与OpenStack服务之间如果要使用ssl进行token认证，就需要使用到openssl
<code>
openssl rand -hex 10
8ac14959ce3d1a4fe213
</code></p>

<p>修改/etc/keystone/keystone.conf的 [DEFAULT]章节
将 admin_token = admin 修改成：</p>

<pre><code>admin_token = 8ac14959ce3d1a4fe213
</code></pre>

<p>再次重启keystone，使其生效</p>

<pre><code>/etc/init.d/keystone restart
</code></pre>

<p>创建User、Tenant、Role、Endpoint、Service
首先创建两个环境变量
<code>
export SERVICE_TOKEN=8ac14959ce3d1a4fe213
export SERVICE_ENDPOINT=http://10.0.0.11:35357/v2.0
</code></p>

<h4>创建租户</h4>

<p>创建两个租户分别是：admin和service
<code>
keystone tenant-create --name=admin --description="Admin Tenant"
keystone tenant-create --name=service --description="Service Tenant"
</code>
上面2个id 暂时需要记录下来，后面将会用到，例如这里是：</p>

<pre><code>admin   a2ba2a4cd7f54d3b9bed90e16def2b8f
service 208807d34ff7455e93b39a2820265349
</code></pre>

<h4>创建用户</h4>

<p><code>
keystone user-create --name=admin --pass=openstack \
--email=admin@domain.com --tenant_id=a2ba2a4cd7f54d3b9bed90e16def2b8f \
--enable=True
</code>
user id同样需要记录下来，例如这里是：
UserId  4fe9772510254b1083962b77d72643c3</p>

<h4>创建角色</h4>

<p>创建一个名称为admin的角色</p>

<pre><code>keystone role-create --name=admin
</code></pre>

<p>截止到目前，已经分别创建 Tenant、User、Role，先不管Service这个租户，分别是：</p>

<p><code>
Tenant ID: a2ba2a4cd7f54d3b9bed90e16def2b8f
User ID:    133e4aa56bba4400a2ccfd4a3ec08b18
Role ID:    0a788b82f9bb4e849af2b402931f58d2
</code>
H版现在不需要我们记录具体的id，貌似只需要指定 名称 即可。</p>

<h4>关联用户、角色、租户</h4>

<p>光创建上面那些身份还不够，最终需要将它们关联起来才能正常使用</p>

<p><code>
keystone user-role-add --user admin --role admin --tenant admin
</code></p>

<h4>创建Services 及 API endpoints</h4>

<p>首先创建一个类型为identity的keystone服务，名称为keystone：</p>

<p><code>
keystone service-create --name=keystone --type=identity \
--description="Keystone Identity Service"
</code></p>

<p>创建endpoint，同样只需要记住service name即可：</p>

<p><code>
keystone endpoint-create --region regionOne \
--service  keystone  \
--publicurl http://10.0.0.11:5000/v2.0 \
--internalurl http://10.0.0.11:5000/v2.0 \
--adminurl http://10.0.0.11:35357/v2.0
</code></p>

<p>验证认证服务(Keystone)安装是否成功
先unset之前的环境变量：</p>

<pre><code>unset OS_SERVICE_TOKEN OS_SERVICE_ENDPOINT
</code></pre>

<p>创建keystonerc(环境变量)</p>

<p>```
export OS_REGION_NAME=regionOne
export OS_USERNAME=admin</p>

<h1>export OS_AUTH_STRATEGE=keystone</h1>

<p>export OS_PASSWORD=openstack
export OS_TENANT_NAME=admin
export OS_AUTH_URL=<a href="http://10.0.0.11:35357/v2.0">http://10.0.0.11:35357/v2.0</a>
OS_NO_CACHE=true
```</p>

<p>添加环境变量
为避免我们每次登录都要设置环境变量，现在将上面参数直接写到一个文件中，在每天登录时使其自动生效，这样我们后期就可以直接通过  keystone subcommand 来使用，创建keystonerc文件，并将下列信息写入keystonerc ：</p>

<p><code>
export OS_USERNAME=admin
export OS_PASSWORD=openstack
export OS_TENANT_NAME=admin
export OS_AUTH_URL=http://10.0.0.11:35357/v2.0
</code>
保存之后并使环境变量立即生效：</p>

<pre><code>source keystonerc
</code></pre>

<p>如果没问题，就能看到token信息。但如果有错误，建议注销当前用户，重新登录后测试一下。</p>

<p>测试是否正常：</p>

<pre><code>keystone token-get
</code></pre>

<p>如果配置正常，将会显示token expires\id\tenant_id\user_id四行。
下一步，我们加一个 &mdash;os_tenant_name参数试下：</p>

<pre><code>keystone --os_tenant_name admin token-get
</code></pre>

<p>如果没问题，将会响应和上面类似的输出信息，区别仅是多一行 tenant_id</p>

<hr />

<h3>Image Service(Glance)安装</h3>

<p>镜像服务我们安装在keystone同一台机器，首先直接安装 镜像服务：</p>

<pre><code>apt-get install -y glance
</code></pre>

<h4>Glance配置</h4>

<p>更新glance配置文件glance-registry.conf：</p>

<pre><code>vim /etc/glance/glance-registry.conf
</code></pre>

<p>修改mysql数据库连接字符串：</p>

<pre><code>sql_connection = mysql://glance:openstack@10.0.0.11/glance
</code></pre>

<p>更新glance配置文件：</p>

<pre><code>vim /etc/glance/glance-api.conf
</code></pre>

<p>在[DEFAULT]章节加入：</p>

<pre><code>sql_connection = mysql://glance:openstack@10.0.0.11/glance
</code></pre>

<p>同步数据库，将会创建镜像服务相关的表：</p>

<pre><code>glance-manage db_sync
</code></pre>

<h4>创建用户</h4>

<p>创建名称为glance的认证用户</p>

<p><code>
keystone user-create --name=glance --pass=glance \
--email=glance@domain.com \
--tenant service --enable=True
</code>
注意，此处的 tenant 就是租户service。</p>

<p>配置Glance与 Keystone访问
编辑配置文件/etc/glance/glance-api.conf 和 /etc/glance/glance-registry.conf，在最后加入以下内容：</p>

<p><code>
[keystone_authtoken]
auth_host = 10.0.0.11
auth_port = 35357
auth_protocol = http
admin_tenant_name = service
admin_user = glance
admin_password = glance
</code></p>

<p>编辑配置文件/etc/glance/glance-api-paste.ini和/etc/glance/glance-registry-paste.ini，将最后几行修改成：</p>

<p><code>
[filter:authtoken]
paste.filter_factory = keystoneclient.middleware.auth_token:filter_factory
service_protocol = http
service_host = 10.0.0.11
service_port = 5000
auth_host = 10.0.0.11
auth_port = 35357
auth_protocol = http
auth_uri = http://10.0.0.11:5000/
admin_tenant_name = service
admin_user = glance
admin_password = glance
</code></p>

<h4>创建service服务和endpoint</h4>

<pre><code>keystone service-create --name=glance --type=image --description="Glance Image Service"
</code></pre>

<p>记录service id，下面创建endpoint将会用到。</p>

<p><code>
keystone endpoint-create --region regionOne \
--service glance \
--publicurl=http://10.0.0.11:9292 \
--internalurl=http://10.0.0.11:9292 \
--adminurl=http://10.0.0.11:9292
</code></p>

<h4>重启glance服务</h4>

<p><code>
/etc/init.d/glance-registry restart
/etc/init.d/glance-api restart
</code></p>

<p>测试镜像服务是否安装成功
镜像文件可以从互联网下载，或自己制作，centos-63.x86_64-cloud.qcow2是偶自己制作的一个镜像文件，即创建一个名称为 centos-63.x86_64-cloud的镜像文件：</p>

<p><code>
glance image-create --name centos-63.x86_64-cloud \
--is-public true --container-format bare \
--disk-format qcow2 &lt; /home/openstack/centos-63.x86_64-cloud.qcow2
</code></p>

<p>如果一切正常，会输出类似以下内容：
<code>
+------------------+--------------------------------------+
| Property         | Value                                |
+------------------+--------------------------------------+
| checksum         | 5c80ad5a5667308b74f6f024317f9924     |
| container_format | bare                                 |
| created_at       | 2013-10-21T12:21:24                  |
| deleted          | False                                |
| deleted_at       | None                                 |
| disk_format      | qcow2                                |
| id               | 79a7fe9f-7f0a-480f-a60d-68f9271ce230 |
| is_public        | True                                 |
| min_disk         | 0                                    |
| min_ram          | 0                                    |
| name             | centos-63.x86_64-cloud               |
| owner            | None                                 |
| protected        | False                                |
| size             | 462219776                            |
| status           | active                               |
| updated_at       | 2013-10-21T12:21:27                  |
+------------------+--------------------------------------+
</code></p>

<p>检查上传是否成功</p>

<pre><code>glance image-list
</code></pre>

<p>如果 Status字段为 active表示上传成功。</p>

<h3>Compute Service(Nova)安装</h3>

<p>控制节点如果在管理并控制计算服务，需要依赖nova，首先安装以下nova包：</p>

<p><code>
apt-get install -y nova-novncproxy novnc nova-api \
nova-ajax-console-proxy nova-cert nova-conductor \
nova-consoleauth nova-doc nova-scheduler python-novaclient
</code></p>

<h4>Nova配置</h4>

<p>修改/etc/nova/nova.conf配置文件，在最后加入：</p>

<pre><code>sql_connection=mysql://nova:openstack@10.0.0.11/nova
</code></pre>

<p>为nova服务创建数据库表：</p>

<pre><code>nova-manage db sync
</code></pre>

<p>配置VNC，修改配置文件/etc/nova/nova.conf，在最后加入：</p>

<p>```</p>

<h1>VNC</h1>

<p>novnc_enabled=True
my_ip=192.168.30.150
novncproxy_base_url=<a href="http://192.168.30.150:6080/vnc_auto.html">http://192.168.30.150:6080/vnc_auto.html</a>
vncserver_listen=0.0.0.0
```</p>

<h4>创建用户与角色</h4>

<p>现在创建一个名称为nova的认证用户和角色</p>

<p><code>
keystone user-create --name=nova --pass=nova \
--email=nova@domain.com \
--tenant service --enable=True
keystone user-role-add --user=nova --tenant=service --role=admin
</code></p>

<p>修改配置文件/etc/nova/nova.conf</p>

<p>```
[DEFAULT]</p>

<p>auth_strategy=keystone
```</p>

<p>修改配置文件/etc/nova/api-paste.ini,并修改以下内容：
<code>
[filter:authtoken]
paste.filter_factory = keystoneclient.middleware.auth_token:filter_factory
auth_host = 10.0.0.11
auth_host = 10.0.0.11
auth_port = 35357
admin_tenant_name = service
admin_user = nova
admin_password = nova
</code></p>

<h4>创建service服务和endpoint</h4>

<pre><code>keystone service-create --name=nova --type=compute --description="Nova Compute Service"
</code></pre>

<p>创建endpoint
<code>
keystone endpoint-create --service nova \
 --publicurl=http://10.0.0.11:8774/v2/%\(tenant_id\)s \
 --internalurl=http://10.0.0.11:8774/v2/%\(tenant_id\)s \
 --adminurl=http://10.0.0.11:8774/v2/%\(tenant_id\)s
</code></p>

<p>配置计算服务使用RabbitMQ,修改配置文件/etc/nova/nova.conf，添加以下内容：</p>

<p><code>
rpc_backend=nova.rpc.impl_kombu
rabbit_host = 10.0.0.11
</code></p>

<p>nova.conf全部内容如下：</p>

<p>```
[DEFAULT]
dhcpbridge_flagfile=/etc/nova/nova.conf
dhcpbridge=/usr/bin/nova-dhcpbridge
logdir=/var/log/nova
state_path=/var/lib/nova
lock_path=/var/lock/nova
force_dhcp_release=True
iscsi_helper=tgtadm
libvirt_use_virtio_for_bridges=True
libvirt_type=qemu
connection_type=libvirt
root_helper=sudo nova-rootwrap /etc/nova/rootwrap.conf
verbose=True
ec2_private_dns_show_ip=True
api_paste_config=/etc/nova/api-paste.ini
volumes_path=/var/lib/nova/volumes
enabled_apis=ec2,osapi_compute,metadata
sql_connection=mysql://nova:openstack@10.0.0.11/nova</p>

<h1>Metadata</h1>

<p>metadata_host=10.0.0.11
metadata_manager=nova.api.manager.MetadataManager
metadata_listen=10.0.0.11
metadata_listen_port=8775</p>

<h1>service_neutron_metadata_proxy=True</h1>

<h1>neutron_metadata_proxy_shared_secret=helloOpenStack</h1>

<h1>Cinder</h1>

<p>volume_api_class=nova.volume.cinder.API
osapi_volume_listen_port=5900</p>

<p>auth_strategy=keystone
rpc_backend=nova.rpc.impl_kombu
rabbit_host = 10.0.0.11</p>

<h1>VNC</h1>

<p>novnc_enabled=True
my_ip=192.168.30.150
novncproxy_base_url=<a href="http://192.168.30.150:6080/vnc_auto.html">http://192.168.30.150:6080/vnc_auto.html</a>
vncserver_listen=0.0.0.0</p>

<h1>vncserver_proxyclient_address=192.168.30.150</h1>

<h1>Network settings</h1>

<p>network_manager=nova.network.manager.FlatDHCPManager
force_dhcp_release=True
dhcpbridge_flagfile=/etc/nova/nova.conf
dhcpbridge=/usr/bin/nova-dhcpbridge
firewall_driver=nova.virt.libvirt.firewall.IptablesFirewallDriver
public_interface=eth2
flat_interface=eth0
floating_range=192.168.30.0/24
flat_network_bridge=br100
fixed_range=10.0.0.0/24 <br/>
network_size=256</p>

<h1>disabled ipv6</h1>

<p>flat_injected=False
connection_type=libvirt
multi_host=True
```</p>

<p>重启所有nova服务</p>

<pre><code>cd /etc/init.d/; for i in $( ls nova-* ); do sudo service $i restart; done
</code></pre>

<p>测试nova是否安装正常</p>

<pre><code>nova image-list
</code></pre>

<p>如果正常，输出的信息和glance image-list是一样的。</p>

<h3>Dashborad(Horizon)安装</h3>

<h4>安装dashboard</h4>

<p>这一步相对容易多了，请看操作：</p>

<pre><code>apt-get install -y memcached libapache2-mod-wsgi openstack-dashboard
</code></pre>

<p>修改/etc/openstack-dashboard/local_settings.py
将OPENSTACK_HOST修改为：</p>

<pre><code>OPENSTACK_HOST = "10.0.0.11"
</code></pre>

<p>登陆dashborad：<a href="http://192.168.30.150/horizon">http://192.168.30.150/horizon</a></p>

<hr />

<h2>计算节点</h2>

<p>以下的示例暂时以一台计算节点来测试安装与部署，即10.0.0.13</p>

<h3>Compute Service(Nova)安装</h3>

<p>为计算节点安装相关的包
<code>
apt-get install -y python-mysqldb
apt-get install nova-compute-kvm python-novaclient python-guestfs
</code></p>

<p>安装过程会提示你，选择”yes”即可。</p>

<p>以下是修复guestfs的一个bug</p>

<pre><code>chmod 0644 /boot/vmlinuz*
</code></pre>

<p>删除SQLite创建的数据库</p>

<pre><code>rm -f /var/lib/nova/nova.sqlite
</code></pre>

<p>配置VNC，编辑/etc/nova/nova.conf在[DEFAULT]章节添加以下信息</p>

<p>```</p>

<h1>VNC</h1>

<p>novnc_enabled=True
novncproxy_base_url=<a href="http://192.168.30.150:6080/vnc_auto.html">http://192.168.30.150:6080/vnc_auto.html</a>
novncproxy_port=6080
vncserver_listen=0.0.0.0
vncserver_proxyclient_address=192.168.30.151
```</p>

<p>编辑/etc/nova/nova.conf，在[DEFAULT]章节添加以下信息</p>

<p><code>
glance_host=10.0.0.11
sql_connection=mysql://nova:openstack@10.0.0.11/nova
</code></p>

<p>添加keystone认证，从控制节点复制api-paste.conf或编辑/etc/nova/api-paste.conf，并添加以下信息</p>

<p><code>
[filter:authtoken]
paste.filter_factory = keystoneclient.middleware.auth_token:filter_factory
auth_host = 10.0.0.11
auth_port = 35357
auth_protocol = http
admin_tenant_name = service
admin_user = nova
admin_password = nova
</code></p>

<h4>启用网络</h4>

<p>在计算节点启用网络
本节的网络示例均使用的nova-network，如果使用neutron，请见Networking Server安装一章。
首先为计算服务安装nova网络包</p>

<pre><code>apt-get install -y nova-network
</code></pre>

<p>设置网络，编辑/etc/nova/nova.conf，增加以下信息</p>

<p><code>
network_manager=nova.network.manager.FlatDHCPManager
firewall_driver=nova.virt.libvirt.firewall.IptablesFirewallDriver
network_size=254
allow_same_net_traffic=False
multi_host=True
send_arp_for_ha=True
share_dhcp_address=True
force_dhcp_release=True
flat_network_bridge=br100
flat_interface=eth1
public_interface=eth1
</code></p>

<p>nova.conf 全部内容如下：</p>

<p>```
[DEFAULT]</p>

<h1>notification_driver=ceilometer.compute.nova_notifier</h1>

<h1>notification_driver=nova.openstack.common.notifier.rpc_notifier</h1>

<p>dhcpbridge_flagfile=/etc/nova/nova.conf
dhcpbridge=/usr/bin/nova-dhcpbridge
logdir=/var/log/nova
state_path=/var/lib/nova
lock_path=/var/lock/nova
force_dhcp_release=True
iscsi_helper=tgtadm
libvirt_use_virtio_for_bridges=True
connection_type=libvirt
root_helper=sudo nova-rootwrap /etc/nova/rootwrap.conf
verbose=True
ec2_private_dns_show_ip=True
api_paste_config=/etc/nova/api-paste.ini
volumes_path=/var/lib/nova/volumes
enabled_apis=ec2,osapi_compute,metadata
sql_connection=mysql://nova:openstack@10.0.0.11/nova
libvirt_type=qemu</p>

<h1>Cinder</h1>

<p>volume_api_class=nova.volume.cinder.API
osapi_volume_listen_port=5900
cinder_catalog_info=volume:cinder:internalURL</p>

<h1>Metadata</h1>

<p>metadata_host=10.0.0.11
metadata_manager=nova.api.manager.MetadataManager
metadata_listen=10.0.0.11
metadata_listen_port=8775</p>

<h1>service_neutron_metadata_proxy=True</h1>

<h1>neutron_metadata_proxy_shared_secret=helloOpenStack</h1>

<h1>Compute</h1>

<p>compute_driver=libvirt.LibvirtDriver</p>

<h1>RabbitMQ</h1>

<p>rpc_backend = nova.rpc.impl_kombu
rabbit_host = 10.0.0.11</p>

<h1>Image Servic3</h1>

<p>glance_host=10.0.0.11
image_service=nova.image.glance.GlanceImageService</p>

<h1>VNC</h1>

<p>novnc_enabled=True</p>

<h1>my_ip=192.168.30.151</h1>

<p>novncproxy_base_url=<a href="http://192.168.30.150:6080/vnc_auto.html">http://192.168.30.150:6080/vnc_auto.html</a>
novncproxy_port=6080
vncserver_listen=0.0.0.0
vncserver_proxyclient_address=192.168.30.151</p>

<h1>Netwok settings</h1>

<p>network_manager=nova.network.manager.FlatDHCPManager
force_dhcp_release=True
dhcpbridge_flagfile=/etc/nova/nova.conf
dhcpbridge=/usr/bin/nova-dhcpbridge
firewall_driver=nova.virt.libvirt.firewall.IptablesFirewallDriver
public_interface=eth2
flat_interface=eth0
floating_range=192.168.30.0/24
flat_network_dhcp_start=10.0.0.40
flat_network_bridge=br100
fixed_range=10.0.0.1/24</p>

<h1>network_size=256</h1>

<p>flat_injected=False
connection_type=libvirt
multi_host=True
dhcp_lease_time=604800
iscsi_helper=tgtadm
```</p>

<p>重启nova服务</p>

<p><code>
/etc/init.d/nova-api restart
/etc/init.d/nova-compute restart
</code></p>

<hr />

<h2>Block Storage (Cinder)安装</h2>

<p>首先得准备一台机器，以下的示例将是在控制节点来安装，同样，你也可以选择在控制节点安装，以下示例中的磁盘设备是/dev/sdb，100G</p>

<h3>配置块存储控制</h3>

<p>安装cinder服务依赖包</p>

<pre><code>apt-get install -y cinder-api cinder-scheduler
</code></pre>

<p>配置块存储服务去使用mysql数据库，编辑/etc/cinder/cinder.conf,添加以下内容</p>

<pre><code>connection = mysql://cinder:openstack@10.0.0.11/cinder
</code></pre>

<p>为块存储服务创建数据库表</p>

<pre><code>cinder-manage db sync
</code></pre>

<h4>创建用户和角色</h4>

<p>创建一个 cinder用户，块存储服务使用这个用户去身份认证，使用service租户且给它admin角色</p>

<p><code>
keystone user-create --name=cinder --pass=cinder --email=cinder@domain.com \
 --tenant service --enable=True
keystone user-role-add --user=cinder --tenant=service --role=admin
</code></p>

<p>编辑/etc/cinder/api-paste.ini，修改以下信息</p>

<p><code>
[filter:authtoken]
paste.filter_factory = keystoneclient.middleware.auth_token:filter_factory
auth_host = 10.0.0.11
auth_port = 35357
auth_protocol = http
admin_tenant_name = service
admin_user = cinder
admin_password = cinder
</code></p>

<h4>创建service和endpoint</h4>

<p><code>
keystone service-create --name=cinder --type=volume --description="Cinder Volume Service"
keystone endpoint-create --service cinder \
--publicurl=http://10.0.0.11:8776/v1/%\(tenant_id\)s \
--internalurl=http://10.0.0.11:8776/v1/%\(tenant_id\)s \
--adminurl=http://10.0.0.11:8776/v1/%\(tenant_id\)s
</code></p>

<p>再来创建个v2的API
<code>
keystone service-create --name=cinder --type=volumev2 \
 --description="Cinder Volume Service V2"
</code></p>

<p>记录service id，以下将会使用到
<code>
keystone endpoint-create \
 --service=98b37a6bd88c44a19bc38586c753cfdd \
 --publicurl=http://10.0.0.11:8776/v2/%\(tenant_id\)s \
 --internalurl=http://10.0.0.11:8776/v2/%\(tenant_id\)s \
 --adminurl=http://10.0.0.11:8776/v2/%\(tenant_id\)s
</code></p>

<p>重启cinder服务
<code>
service cinder-scheduler restart
service cinder-api restart
</code></p>

<h3>配置块存储节点</h3>

<p>配置块存储服务使用RabbitMQ，编辑/etc/cinder/cinder.conf，增加以下信息
<code>
rpc_backend = cinder.openstack.common.rpc.impl_kombu
rabbit_host = 10.0.0.11
rabbit_port = 5672
</code></p>

<p>现在，我们来创建LVM的PV及LV，所以示例全部是使用的第二块设备/dev/sdb，在操作前请确保你的数据是否备份。</p>

<p>安装lvm2和cinder-volume</p>

<pre><code>apt-get install cinder-volume lvm2
</code></pre>

<p>创建PV 和 VG
<code>
root@controller:~# pvcreate /dev/sdb
root@controller:~# vgcreate cinder-volumes /dev/sdb
</code></p>

<p>重启cinder服务
<code>
service cinder-volume restart
service tgt restart
</code></p>

<p>最后去 horizon创建卷就可以使用了，步骤大概为：
1.  管理员自定义卷类型
2.  租户创建卷，并选择一个卷类型
3.  附加到某个VM即可。</p>

<hr />

<h2>Orchestration Server(Heat)安装</h2>

<p>准备一台机器，以下示例将把Heat安装在控制节点，同样，你也可以选择在控制节点安装。</p>

<h3>安装Orchestration服务</h3>

<pre><code>apt-get install -y heat-api heat-api-cfn 
</code></pre>

<p>初始化数据库服务，具体见最开始的 初始化数据库。</p>

<h3>Orchestration配置</h3>

<p>编辑/etc/heat/heat.conf，修改[DEFAULT]节：</p>

<pre><code>sql_connection=mysql://heat:openstack@10.0.0.11/heat
</code></pre>

<p>同步数据库，将会自动创建heat服务的数据库表</p>

<pre><code>heat-manage db_sync
</code></pre>

<h3>创建用户与角色</h3>

<p>创建一个名称为heat的认证用户和角色
<code>
keystone user-create --name=heat --pass=heat \
 --email=heat@domain.com \
 --tenant service --enable=True
</code>
记录user id:  c8b8757e829f461e99a5aa0a72ef78b5</p>

<p>关联租户(service)、用户、角色(admin)
<code>
keystone user-role-add --user-id 6570003a874d4dcc9fd4e3c7f6f16db6 \
 --tenant-id 208807d34ff7455e93b39a2820265349 \
 --role-id 0a788b82f9bb4e849af2b402931f58d2
</code></p>

<h3>创建Heat Service和Endpoint</h3>

<p>创建service</p>

<p>```
keystone service-create &mdash;name=heat &mdash;type=orchestration \
&mdash;description=&ldquo;Heat Orchestration API&rdquo;</p>

<p>keystone endpoint-create &mdash;region regionOne \
&mdash;service-id a5743b1fa56b452f9608d17fdd4dfa2b \
&mdash;publicurl=<a href="http://10.0.0.11:8004/v1/%(tenant_id)s">http://10.0.0.11:8004/v1/%(tenant_id)s</a> \
&mdash;internalurl=<a href="http://10.0.0.11:8004/v1/%(tenant_id)s">http://10.0.0.11:8004/v1/%(tenant_id)s</a>  \
&mdash;adminurl=<a href="http://10.0.0.11:8004/v1/%(tenant_id)s">http://10.0.0.11:8004/v1/%(tenant_id)s</a>
```</p>

<p>heat service id: 06d78bd1404d48698e3f28c01bb2ad30
heat-cfn service id: 507fa3386d4f4d1caa5dc075621e669a</p>

<p>创建endpoint
```
keystone service-create &mdash;name=heat-cfn &mdash;type=cloudformation \
&mdash;description=&ldquo;Heat CloudFormation API&rdquo;</p>

<p>keystone endpoint-create &mdash;region regionOne \
&mdash;service-id a7fae41b733f40efb7472b2a17b97794 \
&mdash;publicurl=<a href="http://10.0.0.11:8000/v1">http://10.0.0.11:8000/v1</a> \
&mdash;internalurl=<a href="http://10.0.0.11:8000/v1">http://10.0.0.11:8000/v1</a>  \
&mdash;adminurl=<a href="http://10.0.0.11:8000/v1">http://10.0.0.11:8000/v1</a>
```</p>

<p>编辑/etc/heat/api-paste.ini，修改[filter:authtoken]节
<code>
[filter:authtoken]
paste.filter_factory = heat.common.auth_token:filter_factory
auth_host = 10.0.0.11
auth_port = 35357
auth_protocol = http
admin_tenant_name = service
admin_user = heat
admin_password = heat
</code></p>

<p>重启Heat服务</p>

<pre><code>cd /etc/init.d/; for i in $( ls heat-* ); do sudo service $i restart; done
</code></pre>

<h3>创建和管理stacks</h3>

<p>从模板创建一个stack,其实官方已经提供很多模板，所以暂时先git下来做测试</p>

<pre><code>git clone https://github.com/openstack/heat-templates.git
</code></pre>

<p>创建stack</p>

<p><code>
heat stack-create mystack \
--template-file=/root/heat-templates/cfn/F18/WordPress_Single_Instance.template \
--parameters="InstanceType=m1.large;DBUsername=wordpress;DBPassword=wordpress;KeyName=HEAT_KEY;LinuxDistribution=F18"
</code>
具体参数请参与官方手册。</p>

<hr />

<h2>Metering/Monitoring Server（Ceilometer）安装</h2>

<h3>安装Metering Service</h3>

<p><strong>1. 在控制节点安装依赖包 </strong></p>

<p><code>
apt-get install -y ceilometer-api ceilometer-collector \
ceilometer-agent-central python-ceilometerclient
</code></p>

<p><strong>2. 安装MongoDB </strong>
Orchestration 服务使用数据库来存储信息，此示例使用MongoDB数据库：</p>

<p><code>
apt-get install -y mongodb
</code></p>

<p>建议将/etc/mongodb.conf中的bind_ip修改为：
<code>
bind_ip=0.0.0.0
</code></p>

<p><strong>3. 重启mongodb生效 </strong></p>

<p><code>
/etc/init.d/mongodb restart
</code></p>

<p><strong>4. 创建数据库和一个 ceilometer用户 </strong></p>

<p>```
root@controller:~# mongo</p>

<blockquote><p>use ceilometer
switched to db ceilometer
db.addUser ( { user: &ldquo;ceilometer&rdquo;,</p>

<pre><code>         pwd: "ceilometer",
         roles: [ "readWrite", "dbAdmin"]
 } )
</code></pre>

<p>```</p></blockquote>

<p><strong>5. 编辑/etc/ceilometer/ceilometer.conf，替换如下： </strong></p>

<p>```
[DEFAULT]
pipeline_cfg_file=pipeline.yaml
sample_source=openstack
nova_control_exchange=nova
libvirt_type=qemu
glance_control_exchange=glance
metering_api_port=8777
debug=true
verbose=true
log_file=/var/log/ceilometer/ceilometer.log
log_dir=/var/log/ceilometer
notification_topics=notifications
policy_file=policy.json
rpc_backend=ceilometer.openstack.common.rpc.impl_kombu
allowed_rpc_exception_modules=ceilometer.openstack.common.exception,nova.exception,cinder.exception,exceptions
control_exchange=openstack
rabbit_host=10.0.0.11
rabbit_port=5672
rabbit_userid=guest
rabbit_password=guest
database_connection=mongodb://ceilometer:ceilometer@10.0.0.11:27017/ceilometer
cinder_control_exchange=cinder</p>

<p>[publisher_rpc]
metering_topic=metering
metering_secret=8ac14959ce3d1a4fe213</p>

<p>[ssl]</p>

<p>[database]
database_connection=mongodb://ceilometer:ceilometer@10.0.0.11:27017/ceilometer</p>

<p>[alarm]</p>

<p>[rpc_notifier2]</p>

<p>[api]</p>

<p>[service_credentials]
os_username=ceilometer
os_password=ceilometer
os_tenant_name=service
os_auth_url=<a href="http://10.0.0.11:5000/v2.0">http://10.0.0.11:5000/v2.0</a>
os_endpoint_type=publicURL</p>

<p>[dispatcher_file]</p>

<p>[keystone_authtoken]
auth_host=10.0.0.11
auth_port=35357
auth_protocol=http
admin_tenant_name=service
admin_user=ceilometer
admin_password=ceilometer
signing_dir=/var/lib/ceilometer/ceilometer-signing</p>

<p>[collector]</p>

<p>[matchmaker_ring]</p>

<p>[matchmaker_redis]
```</p>

<p><strong>6. 创建名称为 ceilometer 的用户，以便使用认证服务。使用service 租户并赋予这个用户admin角色: </strong></p>

<p>```
keystone user-create \
  &mdash;name=ceilometer &mdash;pass=ceilometer \
  &mdash;email=<a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x63;&#101;&#x69;&#x6c;&#111;&#x6d;&#101;&#116;&#101;&#114;&#64;&#100;&#x6f;&#x6d;&#97;&#x69;&#110;&#x2e;&#x63;&#x6f;&#109;">&#99;&#x65;&#x69;&#x6c;&#x6f;&#109;&#x65;&#116;&#x65;&#114;&#64;&#x64;&#111;&#109;&#97;&#x69;&#x6e;&#x2e;&#99;&#x6f;&#x6d;</a></p>

<p>keystone user-role-add &mdash;user=ceilometer &mdash;tenant=service &mdash;role=admin<br/>
```</p>

<p><strong>7. 添加服务和endpoint </strong></p>

<p><code>
keystone service-create --name=ceilometer --type=metering \
 --description="Ceilometer Metering Service"
</code></p>

<p>记录service id，在下面创建endpoint要使用。</p>

<p><code>
keystone endpoint-create \
 --service-id=94ae66fbf5d44c63b7257d0f3c3a48d6 \
 --publicurl=http://10.0.0.11:8777/ \
 --internalurl=http://10.0.0.11:8777/ \
 --adminurl=http://10.0.0.11:8777/
</code></p>

<p><strong>8. 配置认证信息，编辑/etc/ceilometer/ceilometer.conf,修改[keystone_authtoken]节 </strong></p>

<p><code>
[keystone_authtoken]
auth_host=10.0.0.11
auth_port=35357
auth_protocol=http
auth_uri=http://10.0.0.11:35357/v2.0
admin_tenant_name=service
admin_user=ceilometer
admin_password=ceilometer
</code></p>

<p><strong>9. 重启所有ceilometer服务 </strong>
<code>
cd /etc/init.d/; for i in $( ls ceilometer-* ); do sudo service $i restart; done
</code></p>

<h3>添加Agent: 计算</h3>

<p>为收集数据，需要在<strong>计算节点</strong>安装一个Agent。</p>

<p><strong>1. 首先在控制节点安装Metering agent服务 </strong></p>

<pre><code>        apt-get install ceilometer-agent-compute
</code></pre>

<p><strong>2.    编辑/etc/nova/nova.conf，在[DEFAULT]节添加以下信息 </strong></p>

<p>```</p>

<h1>Ceilometer</h1>

<p>instance_usage_audit=True
instance_usage_period=hour
notify_on_state_change=vm_and_task_state
notification_driver=nova.openstack.common.notifier.rpc_notifier
notification_driver=ceilometer.compute.nova_notifier
```</p>

<p><strong>3. 编辑/etc/ceilometer/ceilometer.conf，替换如下： </strong></p>

<p>```
[DEFAULT]
pipeline_cfg_file=pipeline.yaml
sample_source=openstack
nova_control_exchange=nova
libvirt_type=qemu
glance_control_exchange=glance
metering_api_port=8777
debug=true
verbose=true
log_file=/var/log/ceilometer/ceilometer.log
log_dir=/var/log/ceilometer
notification_topics=notifications
policy_file=policy.json
rpc_backend=ceilometer.openstack.common.rpc.impl_kombu
allowed_rpc_exception_modules=ceilometer.openstack.common.exception,nova.exception,cinder.exception,exceptions
control_exchange=openstack
rabbit_host=10.0.0.11
rabbit_port=5672
rabbit_userid=guest
rabbit_password=guest
database_connection=mongodb://ceilometer:ceilometer@10.0.0.11:27017/ceilometer
cinder_control_exchange=cinder</p>

<p>[publisher_rpc]
metering_topic=metering
metering_secret=8ac14959ce3d1a4fe213</p>

<p>[ssl]</p>

<p>[database]
database_connection=mongodb://ceilometer:ceilometer@10.0.0.11:27017/ceilometer</p>

<p>[alarm]</p>

<p>[rpc_notifier2]</p>

<p>[api]</p>

<p>[service_credentials]
os_username=ceilometer
os_password=ceilometer
os_tenant_name=service
os_auth_url=<a href="http://10.0.0.11:5000/v2.0">http://10.0.0.11:5000/v2.0</a>
os_endpoint_type=publicURL</p>

<p>[dispatcher_file]</p>

<p>[keystone_authtoken]
auth_host=10.0.0.11
auth_port=35357
auth_protocol=http
admin_tenant_name=service
admin_user=ceilometer
admin_password=ceilometer
signing_dir=/var/lib/ceilometer/ceilometer-signing</p>

<p>[collector]</p>

<p>[matchmaker_ring]</p>

<p>[matchmaker_redis]</p>

<p>```</p>

<p><strong>4. 重启compute agent服务 </strong></p>

<p><code>
/etc/init.d/ceilometer-agent-compute restart
</code></p>

<h3>添加Agent: 镜像服务</h3>

<p>要测量镜像服务(Image Service)，只需要在glance-api.conf中修改notifier_strategy = noop为
notifier_strategy = rabbit 或者 notifier_strategy = qpid，以下示例使用的rabbit。</p>

<p>修改完成后重启镜像服务：</p>

<p><code>
/etc/init.d/glance-registry restart
/etc/init.d/glance-api restart
</code></p>

<h3>添加Agent: 块存储</h3>

<p><strong>1. 要测量块存储服务(Block Storage)，只需要在cinder.conf中加入以下信息： </strong></p>

<p>```</p>

<h1>Ceilometer</h1>

<p>notification_driver = cinder.openstack.common.notifier.rabbit_notifier
control_exchange = cinder
```</p>

<p><strong>2. 重启cinder相关服务：</strong></p>

<p><code>
/etc/init.d/cinder-volume restart
/etc/init.d/cinder-api restart
</code></p>

<h3>添加Agent: 对象存储</h3>

<p><strong>1. 要访问对象存储(Object Storage)服务就需要ResellerAdmin角色： </strong></p>

<p>```
keystone role-create &mdash;name=ResellerAdmin</p>

<p>keystone user-role-add &mdash;tenant_id 208807d34ff7455e93b39a2820265349 \
&mdash;user_id c538a8fec188450588b71f9d6b6f1ab5 \
&mdash;role_id 56cb34407d5e4ce596e36bd03475be01
```</p>

<h3>测试结果</h3>

<p>设置完之后，我们通过Dashboard来查看结果，来张漂亮的图先</p>

<p><img src="/images/2013/11/openstack-resouce-use.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keystone 源码安装与配置]]></title>
    <link href="http://agenge.github.io/blog/2013/10/24/the-keystone-with-source-installation-and-conf/"/>
    <updated>2013-10-24T09:02:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/10/24/the-keystone-with-source-installation-and-conf</id>
    <content type="html"><![CDATA[<h2>Keystone介绍</h2>

<p>什么是Keystone？
Keystone 作为OpenStack中身份认证服务，在OpenStack起到非常关键的作用。它主要负责身份认证，服务规则及令牌的作用，且实现了Identity API,供OpenStack其他各组件之间来进行身份验证。</p>

<h3>安装依赖包</h3>

<p><code>
apt-get install -y git python-dev sqlite3 libxml2-dev libxslt1-dev libsasl2-dev libsqlite3-dev libssl-dev libldap2-dev
</code></p>

<p><strong> 下载源码 </strong></p>

<p><code>
git clone https://github.com/openstack/keystone.git
git clone https://github.com/openstack/python-keystoneclient.git keystone/client
</code></p>

<p>安装keystone</p>

<p><code>
cd keystone
git checkout origin/stable/grizzly
pip install -r tools/pip-requires
python setup.py install
</code></p>

<p>安装客户端</p>

<p>```
cd client
git checkout -b origin/feature/keystone-v3
pip install -r requirements.txt
python setup.py install</p>

<p>cd ../
mkdir -p /etc/keystone
cp etc/keystone.conf.sample /etc/keystone/keystone.conf
cp etc/logging.conf.sample /etc/keystone/logging.conf
```</p>

<p><strong> 配置日志存放路径 </strong></p>

<p><code>
mkdir -p /var/log/keystone
touch /var/log/keystone/keystone.log
</code></p>

<p>数据库同步，即创建keystone相关的数据库表</p>

<p><code>
keystone-manage db_sync
</code></p>

<p>启动服务</p>

<p><code>
keystone-all -d &amp;
</code></p>

<!-- more -->


<h2>配置Keytone</h2>

<p>截止到现在，我们已经完成Keystone的安装，但现在还无法使用，因为没有租户、用户、密码、服务等。</p>

<p>为使用方便，先设置两个环境变量</p>

<p><code>
export OS_SERVICE_TOKEN=ADMIN
export SERVICE_ENDPOINT=http://192.168.30.150:35357/v2.0
</code></p>

<p>如果前面安装没问题的话，使用以下命令查看用户列表，默认是没有任何数据返回</p>

<p><code>
keystone user-list
</code></p>

<ol>
<li>创建租户</li>
</ol>


<p><code>
keystone tenant-create --name adminTenant --description "Admin Tenant" --enabled true
+-------------+----------------------------------+
|   Property  |              Value               |
+-------------+----------------------------------+
| description |           Admin Tenant           |
|   enabled   |               True               |
|      id     | e36e42a5ed264317a7a5119b1f513e32 |
|     name    |           adminTenant            |
+-------------+----------------------------------+
</code>
需要记录 tenant id，在创建用户时需要关联，即将用户关联到哪个租户。</p>

<ol>
<li>创建用户</li>
</ol>


<p><code>
keystone user-create --tenant_id e36e42a5ed264317a7a5119b1f513e32 --name admin --pass openstack --enabled true
+----------+----------------------------------+
| Property |              Value               |
+----------+----------------------------------+
|  email   |                                  |
| enabled  |               True               |
|    id    | 8cc6ddbeab504e2b9e8bf30eff3d92b7 |
|   name   |              admin               |
| tenantId | e36e42a5ed264317a7a5119b1f513e32 |
+----------+----------------------------------+
</code></p>

<ol>
<li>创建角色</li>
</ol>


<p>创建一个角色名称为adminRole。请记住该命令生成的Role id，下面的关联用户及租户时需要用到</p>

<p><code>
keystone role-create --name adminRole
+----------+----------------------------------+
| Property |              Value               |
+----------+----------------------------------+
|    id    | a00bf7b7fe4e4746bac0fd69778f3dfa |
|   name   |            adminRole             |
+----------+----------------------------------+
</code></p>

<p>截止到目前，已经分别创建 Tenant、User、Role，分别是：</p>

<p>Tenant ID:  e36e42a5ed264317a7a5119b1f513e32
User ID:    8cc6ddbeab504e2b9e8bf30eff3d92b7
Role ID:    a00bf7b7fe4e4746bac0fd69778f3dfa</p>

<p>现在将它们三者关联到一起</p>

<p><code>
keystone user-role-add --user-id 8cc6ddbeab504e2b9e8bf30eff3d92b7 \
 --tenant-id e36e42a5ed264317a7a5119b1f513e32 \
 --role-id a00bf7b7fe4e4746bac0fd69778f3dfa
</code></p>

<h2>Keytone测试</h2>

<h3>通过 Keystone 获取 Token</h3>

<p>访问Keystone 需要4个参数：TenantName Username Password 申请URL，其中URL可以是：</p>

<pre><code>http://192.168.30.150:35357/v2.0/tokens 或 http://192.168.30.150:5000/v2.0/tokens
</code></pre>

<p><code>
curl -d '{"auth": {"tenantName": "adminTenant", "passwordCredentials":{"username": "admin", "password": "openstack"}}}' -H "Content-type: application/json" http://192.168.30.150:35357/v2.0/tokens | python -mjson.tool
</code>
将会返回以下类似信息</p>

<p>```
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</p>

<pre><code>                             Dload  Upload   Total   Spent    Left  Speed
</code></pre>

<p>100   676  100   567  100   109   6290   1209 &mdash;:&mdash;:&mdash; &mdash;:&mdash;:&mdash; &mdash;:&mdash;:&mdash;  6517
{</p>

<pre><code>"access": {
    "metadata": {
        "is_admin": 0, 
        "roles": [
            "9fe2ff9ee4384b1894a90878d3e92bab", 
            "a00bf7b7fe4e4746bac0fd69778f3dfa"
        ]
    }, 
    "serviceCatalog": [], 
    "token": {
        "expires": "2013-10-16T09:03:21Z", 
        "id": "7c76f8315f6e42d6a05b0ed726bc3441", 
        "issued_at": "2013-10-15T09:03:21.809471", 
        "tenant": {
            "description": "Admin Tenant", 
            "enabled": true, 
            "id": "e36e42a5ed264317a7a5119b1f513e32", 
            "name": "adminTenant"
        }
    }, 
    "user": {
        "id": "8cc6ddbeab504e2b9e8bf30eff3d92b7", 
        "name": "admin", 
        "roles": [
            {
                "name": "_member_"
            }, 
            {
                "name": "adminRole"
            }
        ], 
        "roles_links": [], 
        "username": "admin"
    }
}
</code></pre>

<p>}
```</p>

<p>从上述返回结果能看到正常返回 token。更详细的操作请参考<a href="http://agenge.com/blog/2013/10/17/use-the-curl-operation-swift/">使用Curl操作OpenStack Swift</a></p>

<h2>错误汇总</h2>

<p>```
Traceback (most recent call last):
   File &ldquo;/usr/bin/easy_install&rdquo;, line 5, in <module></p>

<pre><code> from pkg_resources import load_entry_point ImportError: No module named pkg_resources raid:/home/linyoujushi# easy_install genshi Traceback (most recent call last):
</code></pre>

<p>```</p>

<p>解决办法：</p>

<p>这是由于我们没有安装setuptools或者没有装好，我们只需要安装这个软件就行了。安装方法：</p>

<p><code>
wget http://peak.telecommunity.com/dist/ez_setup.py
python ez_setup.py
</code></p>

<p>或者，我们装的setuptools工具太老，我们升级一下：</p>

<p><code>
sudo python ./ez_setup.py -U setuptools
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Curl操作OpenStack Swift]]></title>
    <link href="http://agenge.github.io/blog/2013/10/17/use-the-curl-operation-swift/"/>
    <updated>2013-10-17T09:51:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/10/17/use-the-curl-operation-swift</id>
    <content type="html"><![CDATA[<p>提示：以下操作均是使用的 swift tempauth认证机制。</p>

<ul>
<li>获取 Token</li>
</ul>


<p>```</p>

<pre><code>curl -k -v -H 'X-Storage-User: admin:admin' -H 'X-Storage-Pass: admin' http://192.168.30.150:8080/auth/v1.0
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
* About to connect() to 192.168.30.150 port 8080 (#0)
*   Trying 192.168.30.150&hellip; connected</p>

<blockquote><p>GET /auth/v1.0 HTTP/1.1
User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
Host: 192.168.30.150:8080
Accept: <em>/</em>
X-Storage-User: admin:admin
X-Storage-Pass: admin</p>

<p>&lt; HTTP/1.1 200 OK
&lt; X-Storage-Url: <a href="http://192.168.30.150:8080/v1/AUTH_admin">http://192.168.30.150:8080/v1/AUTH_admin</a>
&lt; X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Type: text/html; charset=UTF-8
&lt; X-Storage-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Length: 0
&lt; Date: Tue, 15 Oct 2013 01:49:59 GMT
&lt;
* Connection #0 to host 192.168.30.150 left intact
* Closing connection #0
```</p></blockquote>

<ul>
<li>Account操作</li>
</ul>


<p>```</p>

<pre><code>curl -k -v -X HEAD -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
* About to connect() to 192.168.30.150 port 8080 (#0)
*   Trying 192.168.30.150&hellip; connected</p>

<blockquote><p>HEAD /v1/AUTH_admin HTTP/1.1
User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
Host: 192.168.30.150:8080
Accept: <em>/</em>
X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5</p>

<p>&lt; HTTP/1.1 204 No Content
&lt; Content-Length: 0
&lt; Accept-Ranges: bytes
&lt; X-Timestamp: 1381806617.24083
&lt; X-Account-Bytes-Used: 0
&lt; X-Account-Container-Count: 1
&lt; Content-Type: text/plain; charset=utf-8
&lt; X-Account-Object-Count: 0
&lt; Date: Tue, 15 Oct 2013 05:17:23 GMT
&lt;
* Connection #0 to host 192.168.30.150 left intact
* Closing connection #0
```</p></blockquote>

<ul>
<li><p>Container操作</p>

<ul>
<li>列出 Contailner</li>
</ul>
</li>
</ul>


<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin
</code>
 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 5
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 1
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:20:11 GMT</p>

<p>test
```
 最后一行的test就是查询出来的内容。</p>

<ul>
<li>创建 Container</li>
</ul>


<p><code>
curl -i -X PUT -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile
</code></p>

<p>   如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 201 Created
Content-Length: 0
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:22:01 GMT
</code></p>

<p>  我们再来查询一次看是否成功：</p>

<p>  <!-- more --></p>

<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin
</code></p>

<p>  如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 12
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:23:18 GMT</p>

<p>myfile
test
```</p>

<ul>
<li> 只列出部分 Container</li>
</ul>


<p>  很多时候 Container 会有很多个，Swift 默认会列出前10000个，但如果我们只看最前面几个，该怎么办？ 以下示例只显示最前面一个 Container</p>

<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin?limit=1
</code></p>

<p> 结果：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 7
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:24:36 GMT</p>

<p>myfile
```</p>

<p>  那如果要列出最后几个 Container 又怎么办呢？ 加一个 marker即可，以下示例列出 myfile之后的一个Container</p>

<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin?marker=myfile\&amp;limit=1
</code></p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 5
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:28:53 GMT</p>

<p>test
```</p>

<ul>
<li>格式化输出 Container</li>
</ul>


<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin?format=json
</code></p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 86
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: application/json; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:29:58 GMT</p>

<p>[{&ldquo;count&rdquo;: 0, &ldquo;bytes&rdquo;: 0, &ldquo;name&rdquo;: &ldquo;myfile&rdquo;}, {&ldquo;count&rdquo;: 0, &ldquo;bytes&rdquo;: 0, &ldquo;name&rdquo;: &ldquo;test&rdquo;}]
```</p>

<p>  除了JSON格式，还可以格式化XML，只需要将json改成xml 即可。</p>

<ul>
<li>查看 Container metadata</li>
</ul>


<p><code>
curl -i -X HEAD -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/test
</code></p>

<p>  如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 204 No Content
Content-Length: 0
X-Container-Object-Count: 0
Accept-Ranges: bytes
X-Timestamp: 1381806903.70007
X-Container-Bytes-Used: 0
Content-Type: text/plain; charset=utf-8
Date: Tue, 15 Oct 2013 05:32:06 GMT
</code></p>

<ul>
<li>删除 Container</li>
</ul>


<p><code>
curl -i -X DELETE -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/mytest
</code></p>

<ul>
<li><p>Object操作</p>

<ul>
<li>创建 Object</li>
</ul>
</li>
</ul>


<p><code>
curl -k -i -X PUT -T "apache-tomcat-6.0.36.tgz" -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile/apache-tomcat-6.0.36.tgz
</code></p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 100 Continue</p>

<p>HTTP/1.1 201 Created
Last-Modified: Tue, 15 Oct 2013 05:39:07 GMT
Content-Length: 0
Etag: 3dde098fd0b3a08d3f2867e4a95591ba
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:39:08 GMT
```</p>

<ul>
<li>列出  Object</li>
</ul>


<p>```</p>

<pre><code>curl -k -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile
</code></pre>

<p>```</p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 25
X-Container-Object-Count: 1
Accept-Ranges: bytes
X-Timestamp: 1381814521.71796
X-Container-Bytes-Used: 6780936
Content-Type: text/plain; charset=utf-8
Date: Tue, 15 Oct 2013 05:40:43 GMT</p>

<p>apache-tomcat-6.0.36.tgz
```</p>

<p>另外 Object和 Container一样可以通过加参数来限制查询，具体示例可参考 Container操作。</p>

<ul>
<li>下载 Object</li>
</ul>


<p>```</p>

<pre><code>curl -k -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile/apache-tomcat-6.0.36.tgz &gt; apache-tomcat-6.0.36.tgz
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</p>

<pre><code>                             Dload  Upload   Total   Spent    Left  Speed
</code></pre>

<p>100 6622k  100 6622k    0     0  32.8M      0 &mdash;:&mdash;:&mdash; &mdash;:&mdash;:&mdash; &mdash;:&mdash;:&mdash; 33.1M
```</p>

<ul>
<li>Copy Object</li>
</ul>


<p><code>
curl -k -i -X PUT -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' \
 -H 'X-Copy-From: /myfile/apache-tomcat-6.0.36.tgz' \
 -H 'Content-Length:0' http://192.168.30.150:8080/v1/AUTH_admin/test/apache-tomcat-6.0.36.tgz
</code></p>

<p>将/myfile/apache-tomcat-6.0.36.tgz 拷贝到 /test/apache-tomcat-6.0.36.tgz,如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 201 Created
Content-Length: 0
X-Copied-From-Last-Modified: Tue, 15 Oct 2013 05:39:07 GMT
X-Copied-From: myfile/apache-tomcat-6.0.36.tgz
Last-Modified: Tue, 15 Oct 2013 05:47:52 GMT
Etag: 3dde098fd0b3a08d3f2867e4a95591ba
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:47:52 GMT
</code></p>

<ul>
<li>删除 Object</li>
</ul>


<p>```</p>

<pre><code>curl -k -i -X DELETE -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/test/apache-tomcat-6.0.36.tgz
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 204 No Content
Content-Length: 0
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:50:49 GMT
</code>
 通过之前的GET就能验证是否成功删除，此处略过。</p>

<ul>
<li>设置 Object Metadata</li>
</ul>


<p><code>
curl -k -i -X POST -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' \
-H 'X-Object-Meta-Breed: apache tomcat 6.0.36' \
 http://192.168.30.150:8080/v1/AUTH_admin/myfile/apache-tomcat-6.0.36.tgz
</code></p>

<p>如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 202 Accepted
Content-Length: 76
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:54:09 GMT
</code></p>

<p>通过之前的HEAD，就能查看到刚才添加的元数据</p>

<p><code>
HTTP/1.1 200 OK
Content-Length: 6780936
X-Object-Meta-Breed: apache tomcat 6.0.36
Accept-Ranges: bytes
Last-Modified: Tue, 15 Oct 2013 05:54:08 GMT
Etag: 3dde098fd0b3a08d3f2867e4a95591ba
X-Timestamp: 1381816448.74507
Content-Type: application/x-tar
Date: Tue, 15 Oct 2013 05:55:53 GMT
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStack Swift安装与配置]]></title>
    <link href="http://agenge.github.io/blog/2013/10/15/openstack-swift-install/"/>
    <updated>2013-10-15T14:00:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/10/15/openstack-swift-install</id>
    <content type="html"><![CDATA[<h2>准备环境</h2>

<p><code>
192.168.30.150  proxy server
192.168.30.151  storage server
192.168.30.152  storage server
</code></p>

<h2>网络配置</h2>

<p><strong> Proxy 代理节点网络(单网卡)  </strong></p>

<p>```
auto lo
iface lo inet loopback</p>

<h1>The primary network interface</h1>

<p>auto eth0
iface eth0 inet static
address 192.168.30.150
netmask 255.255.255.0
gateway 192.168.30.1
network 192.168.30.0
broadcast 192.168.30.255
dns-nameservers 218.201.4.3
```</p>

<p><strong> 存储节点网络(单网卡)  </strong>
存储节点1：</p>

<p>```
auto lo
iface lo inet loopback</p>

<h1>The primary network interface</h1>

<p>auto eth0
iface eth0 inet static
address 192.168.30.151
netmask 255.255.255.0
gateway 192.168.30.1
network 192.168.30.0
broadcast 192.168.30.255
dns-nameservers 218.201.4.3
```</p>

<p>存储节点2：</p>

<p>```
auto lo
iface lo inet loopback</p>

<h1>The primary network interface</h1>

<p>auto eth0
iface eth0 inet static
address 192.168.30.152
netmask 255.255.255.0
gateway 192.168.30.1
network 192.168.30.0
broadcast 192.168.30.255
dns-nameservers 218.201.4.3
```</p>

<h2>安装公共组件</h2>

<p>以下操作在所有节点全部安装：</p>

<h3>添加源</h3>

<p><code>
cat &gt; /etc/apt/sources.list.d/grizzly.list &lt;&lt; _END_
deb http://ubuntu-cloud.archive.canonical.com/ubuntu precise-updates/grizzly main
deb  http://ubuntu-cloud.archive.canonical.com/ubuntu precise-proposed/grizzly main
_END_
</code></p>

<p>更新源</p>

<p><code>
sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 5EDB1B62EC4926EA
apt-get update
apt-get upgrade
apt-get install ubuntu-cloud-keyring
</code></p>

<!-- more -->


<h2>安装 Swift</h2>

<p><code>
os_swift="python-swift swift swift-proxy swift-account swift-container swift-object python-memcache xfsprogs"
os_keystone="python-keystone python-keystoneclient"
apt-get install -y $os_swift $os_keystone
</code></p>

<p>安装之后需要手工创建 swift相关配置文件:</p>

<p><code>
mkdir /etc/swift
touch /etc/swift/swift.conf
touch /etc/swift/proxy-server.conf
chown -R swift:swift /etc/swift
</code></p>

<p>添加 swift.conf内容：</p>

<p>```
cat > /etc/swift/swift.conf &lt;&lt; <em>END</em>
[swift-hash]</p>

<h1>od -t x8 -N 8 -A n &lt; /dev/random</h1>

<h1>The above command can be used to generate random a string.</h1>

<p>swift_hash_path_suffix = 50ea1ddb6e88b991
<em>END</em>
```</p>

<p>将以下内容添加到 /etc/swift/proxy-server.conf内容：</p>

<p>```
[DEFAULT]
bind_port = 8080
bind_ip = 0.0.0.0
user = swift
swift_dir = /etc/swift</p>

<p>log_facility = LOG_LOCAL0
log_level = DEBUG</p>

<p>[pipeline:main]
pipeline = catch_errors healthcheck cache authtoken keystoneauth container-quotas account-quotas proxy-server</p>

<p>[app:proxy-server]
use = egg:swift#proxy
allow_account_management = true
account_autocreate = true</p>

<p>[filter:keystoneauth]
use = egg:swift#keystoneauth
operator_roles = Member,admin</p>

<p>[filter:authtoken]
paste.filter_factory = keystone.middleware.auth_token:filter_factory
service_protocol = http
service_port = 5000
service_host = 192.168.30.150
auth_port = 35357
auth_host = 192.168.30.150
auth_protocol = http
admin_tenant_name = service
admin_user = swift
admin_password = password
signing_dir = /etc/swift</p>

<p>[filter:cache]
use = egg:swift#memcache
set log_name = cache
memcache_servers = 192.168.30.150:11211</p>

<p>[filter:catch_errors]
use = egg:swift#catch_errors</p>

<p>[filter:healthcheck]
use = egg:swift#healthcheck</p>

<p>[filter:proxy-logging]
use = egg:swift#proxy_logging</p>

<p>[filter:ratelimit]
use = egg:swift#ratelimit
[filter:container-quotas]
use = egg:swift#container_quotas</p>

<p>[filter:account-quotas]
use = egg:swift#account_quotas
```</p>

<p>如果不使用 Keystone 认证，请使用以下的配置文件：</p>

<p>```
[DEFAULT]
bind_port = 8080
bind_ip = 192.168.30.150
user = swift</p>

<p>[pipeline:main]
pipeline = healthcheck cache tempauth proxy-server</p>

<p>[app:proxy-server]
use = egg:swift#proxy
allow_account_management = true
account_autocreate = true</p>

<p>[filter:tempauth]
use = egg:swift#tempauth
user_admin_admin = admin .admin .reseller_admin
user_test_tester = testing .admin
user_test2_tester2 = testing2 .admin
user_test_tester3 = testing3</p>

<p>[filter:healthcheck]
use = egg:swift#healthcheck</p>

<p>[filter:cache]
use = egg:swift#memcache
memcache_servers = 192.168.30.150:11211
```</p>

<p>格式： user<em><login1></em><login2> = <password> <privileges>
登录的时候就是：</p>

<p><code>
login = admin:admin
password = admin
privileges = .admin .reseller_admin
</code></p>

<p>配置rsyslog</p>

<p><code>
echo "local0.*    /var/log/swift/proxy-server.log" &gt;&gt; /etc/rsyslog.conf
mkdir /var/log/swift
</code></p>

<p>配置 环 Ring</p>

<p><code>
cd /etc/swift
sudo swift-ring-builder account.builder create 6 2 1
sudo swift-ring-builder container.builder create 6 2 1
sudo swift-ring-builder object.builder create 6 2 1
</code>
说明</p>

<ul>
<li>第一个数字：6表示分区(环)将被处理为2<sup>6th</sup>，即使用2的6次方个分区，创建完之后应有 64个分区</li>
<li>第二个数字：每个存储对象保存2份，即创建2个副本；由于偶只有两台storage，故只写2</li>
<li>第三个数字：1表示限制分区数据转移的时间，此处表示1小时，即分区被连续移动两次之间的最小时间间隔</li>
</ul>


<p>添加设备
添加新设备到Ring上，但add操作不会分配partitions到新的设备上，只有运行“rebalance”命令后才会进行分区的分配，所以这种方式可以有这种优势： 允许一次添加多个设备，只执行一次rebalance就可以了，以下操作步骤：</p>

<p>```
sudo swift-ring-builder account.builder add z1-192.168.30.151:6002/sdb1 100
sudo swift-ring-builder account.builder add z2-192.168.30.152:6002/sdb1 100</p>

<p>sudo swift-ring-builder container.builder add z1-192.168.30.151:6001/sdb1 100
sudo swift-ring-builder container.builder add z2-192.168.30.152:6001/sdb1 100</p>

<p>sudo swift-ring-builder object.builder add z1-192.168.30.151:6000/sdb1 100
sudo swift-ring-builder object.builder add z2-192.168.30.152:6000/sdb1 100
```</p>

<p>查看 Ring信息
可通过以下命令查到到Ring和Ring中的设备信息：
* 查询account信息：</p>

<pre><code>    swift-ring-builder account.builder
</code></pre>

<ul>
<li><p>查询container信息：</p>

<pre><code>  swift-ring-builder container.builder
</code></pre></li>
<li><p>查询object信息</p>

<pre><code>  swift-ring-builder object.builder
</code></pre></li>
<li><p>生成 Ring
如果确认一切之后，最终还要生成Ring，来进行分区的分配，即之前提到的rebalance：</p></li>
</ul>


<p><code>
sudo swift-ring-builder account.builder rebalance
sudo swift-ring-builder container.builder rebalance
sudo swift-ring-builder object.builder rebalance
</code></p>

<p>设置权限</p>

<p><code>
chown -R swift:swift /etc/swift
chown -R swift:swift /var/cache/swift
</code></p>

<hr />

<h2>存储节点安装与配置</h2>

<p>添加设备：
先创建分区，另外一定要是 XFS文件系统</p>

<p><code>
mkdir -p /srv/node/sdb1
chown -R swift:swift /srv/node/
mkfs.xfs -i size=1024 /dev/sdb1 -f
echo "/dev/sdb1 /srv/node/sdb1 xfs noatime,nodiratime,nobarrier,logbufs=8 0 0" &gt;&gt; /etc/fstab
mount /srv/node/sdb1  
</code></p>

<p>设置 rsyncd.conf</p>

<p>```
uid = swift
gid = swift</p>

<p>log file = /var/log/rsyncd.log
pid file = /var/run/rsyncd.pid
address = 192.168.30.151</p>

<p>[account]
max_connections = 2
path = /srv/node/
read only = false
lock file = /var/lock/account.lock</p>

<p>[container]
max_connections = 2
path = /srv/node/
read only = false
lock file = /var/lock/container.lock</p>

<p>[object]
max_connections = 2
path = /srv/node/
read only = false
lock file = /var/lock/object.lock
```</p>

<p>设置 rsync开机自启动</p>

<pre><code>sudo sed -i 's/RSYNC_ENABLE=false/RSYNC_ENABLE=true/g' /etc/default/rsync
</code></pre>

<p>启动 rsync服务</p>

<pre><code>sudo service rsync start
</code></pre>

<p>创建/etc/account-server.conf：</p>

<p>```
[DEFAULT]
bind_ip = 0.0.0.0
bind_port = 6002
workers = 1
user = swift
swift_dir = /etc/swift
devices = /srv/node</p>

<p>[pipeline:main]
pipeline = account-server</p>

<p>[app:account-server]
use = egg:swift#account</p>

<p>[account-replicator]</p>

<p>[account-auditor]</p>

<p>[account-reaper]</p>

<p>```</p>

<p>创建/etc/container-server.conf</p>

<p>```
[DEFAULT]
bind_ip = 0.0.0.0
bind_port = 6001
workers = 1
user = swift
swift_dir = /etc/swift
devices = /srv/node</p>

<p>[pipeline:main]
pipeline = container-server</p>

<p>[app:container-server]
use = egg:swift#container</p>

<p>[container-replicator]</p>

<p>[container-updater]</p>

<p>[container-auditor]</p>

<p>[container-sync]
```</p>

<p>创建/etc/object-server.conf</p>

<p>```
[DEFAULT]
bind_ip = 0.0.0.0
bind_port = 6000
workers = 1
user = swift
swift_dir = /etc/swift
devices = /srv/node</p>

<p>[pipeline:main]
pipeline = recon object-server</p>

<p>[app:object-server]
use = egg:swift#object</p>

<p>[filter:recon]
use = egg:swift#recon
recon_cache_path = /var/cache/swift</p>

<p>[object-replicator]</p>

<p>[object-updater]</p>

<p>[object-auditor]
```</p>

<h3>重启服务</h3>

<p>在所有存储节点重启以下服务：</p>

<p><code>
sudo swift-init object-server start
sudo swift-init object-replicator start
sudo swift-init object-updater start
sudo swift-init object-auditor start
sudo swift-init container-server start
sudo swift-init container-replicator start
sudo swift-init container-updater start
sudo swift-init container-auditor start
sudo swift-init account-server start
sudo swift-init account-replicator start
sudo swift-init account-auditor start
</code></p>

<p>在代理节点启动以下服务：</p>

<p><code>
sudo swift-init all restart
</code></p>

<h2>Swift操作</h2>

<p>获得 X-Storage-Url 和 X-Auth-Token:</p>

<pre><code>curl -k -v -H 'X-Storage-User: admin:admin' -H 'X-Storage-Pass: admin' http://192.168.30.150:8080/auth/v1.0
</code></pre>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
* About to connect() to 192.168.30.150 port 8080 (#0)
*   Trying 192.168.30.150&hellip; connected</p>

<blockquote><p>GET /auth/v1.0 HTTP/1.1
User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
Host: 192.168.30.150:8080
Accept: <em>/</em>
X-Storage-User: admin:admin
X-Storage-Pass: admin</p>

<p>&lt; HTTP/1.1 200 OK
&lt; X-Storage-Url: <a href="http://192.168.30.150:8080/v1/AUTH_admin">http://192.168.30.150:8080/v1/AUTH_admin</a>
&lt; X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Type: text/html; charset=UTF-8
&lt; X-Storage-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Length: 0
&lt; Date: Tue, 15 Oct 2013 01:49:59 GMT
&lt;
* Connection #0 to host 192.168.30.150 left intact
* Closing connection #0
```</p></blockquote>

<p>检查账号</p>

<pre><code>    curl -k -v -H 'X-Auth-Token: &lt;token-from-x-auth-token-above&gt;' &lt;url-from-xstorage-url-above&gt;  
</code></pre>

<p>这里的token-from-x-auth-token-above 就是上面输出的 AUTH_tk8a85916d63b14c568a4633b7920623c5，url-from-xstorage-url-above对应：<a href="http://192.168.30.150:8080/v1/AUTH_admin">http://192.168.30.150:8080/v1/AUTH_admin</a></p>

<p>检测 swift 命令是否工作正常</p>

<pre><code>    swift -A http://192.168.30.150:8080/auth/v1.0 -U admin:admin -K admin stat
</code></pre>

<p>正常输出类似以下信息：</p>

<p>```
   Account: AUTH_admin
Containers: 0
   Objects: 0</p>

<pre><code> Bytes: 0
</code></pre>

<p>Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
Content-Type: text/plain; charset=utf-8
```</p>

<p>上传</p>

<pre><code>swift -A http://192.168.30.150:8080/auth/v1.0 -U admin:admin -K admin upload test apache-tomcat-6.0.36.tar.gz
</code></pre>

<p>删除</p>

<pre><code>swift -A http://192.168.30.150:8080/auth/v1.0 -U admin:admin -K admin delete test apache-tomcat-6.0.36.tar.gz
</code></pre>

<h2>排错思路</h2>

<ol>
<li>直接看控制台打印的日志</li>
<li>检查配置文件是否正确</li>
<li>通过观察日志，例如/var/log/syslog</li>
<li>修改配置文件之后，需要重启对应的服务</li>
</ol>

]]></content>
  </entry>
  
</feed>
