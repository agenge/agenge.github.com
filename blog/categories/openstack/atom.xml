<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[文章分类: OpenStack | TaurusHome]]></title>
  <link href="http://agenge.github.io/blog/categories/openstack/atom.xml" rel="self"/>
  <link href="http://agenge.github.io/"/>
  <updated>2013-10-17T11:57:24+08:00</updated>
  <id>http://agenge.github.io/</id>
  <author>
    <name><![CDATA[agenge]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Curl操作OpenStack Swift]]></title>
    <link href="http://agenge.github.io/blog/2013/10/17/use-the-curl-operation-swift/"/>
    <updated>2013-10-17T09:51:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/10/17/use-the-curl-operation-swift</id>
    <content type="html"><![CDATA[<p>提示：以下操作均是使用的 swift tempauth认证机制。</p>

<ul>
<li>获取 Token</li>
</ul>


<p>```</p>

<pre><code>curl -k -v -H 'X-Storage-User: admin:admin' -H 'X-Storage-Pass: admin' http://192.168.30.150:8080/auth/v1.0
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
* About to connect() to 192.168.30.150 port 8080 (#0)
*   Trying 192.168.30.150&hellip; connected</p>

<blockquote><p>GET /auth/v1.0 HTTP/1.1
User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
Host: 192.168.30.150:8080
Accept: <em>/</em>
X-Storage-User: admin:admin
X-Storage-Pass: admin</p>

<p>&lt; HTTP/1.1 200 OK
&lt; X-Storage-Url: <a href="http://192.168.30.150:8080/v1/AUTH_admin">http://192.168.30.150:8080/v1/AUTH_admin</a>
&lt; X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Type: text/html; charset=UTF-8
&lt; X-Storage-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Length: 0
&lt; Date: Tue, 15 Oct 2013 01:49:59 GMT
&lt;
* Connection #0 to host 192.168.30.150 left intact
* Closing connection #0
```</p></blockquote>

<ul>
<li>Account操作</li>
</ul>


<p>```</p>

<pre><code>curl -k -v -X HEAD -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
* About to connect() to 192.168.30.150 port 8080 (#0)
*   Trying 192.168.30.150&hellip; connected</p>

<blockquote><p>HEAD /v1/AUTH_admin HTTP/1.1
User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
Host: 192.168.30.150:8080
Accept: <em>/</em>
X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5</p>

<p>&lt; HTTP/1.1 204 No Content
&lt; Content-Length: 0
&lt; Accept-Ranges: bytes
&lt; X-Timestamp: 1381806617.24083
&lt; X-Account-Bytes-Used: 0
&lt; X-Account-Container-Count: 1
&lt; Content-Type: text/plain; charset=utf-8
&lt; X-Account-Object-Count: 0
&lt; Date: Tue, 15 Oct 2013 05:17:23 GMT
&lt;
* Connection #0 to host 192.168.30.150 left intact
* Closing connection #0
```</p></blockquote>

<ul>
<li><p>Container操作</p>

<ul>
<li>列出 Contailner</li>
</ul>
</li>
</ul>


<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin
</code>
 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 5
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 1
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:20:11 GMT</p>

<p>test
```
 最后一行的test就是查询出来的内容。</p>

<ul>
<li>创建 Container</li>
</ul>


<p><code>
curl -i -X PUT -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile
</code></p>

<p>   如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 201 Created
Content-Length: 0
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:22:01 GMT
</code></p>

<p>  我们再来查询一次看是否成功：</p>

<p>  <!-- more --></p>

<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin
</code></p>

<p>  如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 12
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:23:18 GMT</p>

<p>myfile
test
```</p>

<ul>
<li> 只列出部分 Container</li>
</ul>


<p>  很多时候 Container 会有很多个，Swift 默认会列出前10000个，但如果我们只看最前面几个，该怎么办？ 以下示例只显示最前面一个 Container</p>

<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin?limit=1
</code></p>

<p> 结果：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 7
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:24:36 GMT</p>

<p>myfile
```</p>

<p>  那如果要列出最后几个 Container 又怎么办呢？ 加一个 marker即可，以下示例列出 myfile之后的一个Container</p>

<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin?marker=myfile\&amp;limit=1
</code></p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 5
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: text/plain; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:28:53 GMT</p>

<p>test
```</p>

<ul>
<li>格式化输出 Container</li>
</ul>


<p><code>
curl -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin?format=json
</code></p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 86
Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
X-Account-Bytes-Used: 0
X-Account-Container-Count: 2
Content-Type: application/json; charset=utf-8
X-Account-Object-Count: 0
Date: Tue, 15 Oct 2013 05:29:58 GMT</p>

<p>[{&ldquo;count&rdquo;: 0, &ldquo;bytes&rdquo;: 0, &ldquo;name&rdquo;: &ldquo;myfile&rdquo;}, {&ldquo;count&rdquo;: 0, &ldquo;bytes&rdquo;: 0, &ldquo;name&rdquo;: &ldquo;test&rdquo;}]
```</p>

<p>  除了JSON格式，还可以格式化XML，只需要将json改成xml 即可。</p>

<ul>
<li>查看 Container metadata</li>
</ul>


<p><code>
curl -i -X HEAD -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/test
</code></p>

<p>  如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 204 No Content
Content-Length: 0
X-Container-Object-Count: 0
Accept-Ranges: bytes
X-Timestamp: 1381806903.70007
X-Container-Bytes-Used: 0
Content-Type: text/plain; charset=utf-8
Date: Tue, 15 Oct 2013 05:32:06 GMT
</code></p>

<ul>
<li>删除 Container</li>
</ul>


<p><code>
curl -i -X DELETE -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/mytest
</code></p>

<ul>
<li><p>Object操作</p>

<ul>
<li>创建 Object</li>
</ul>
</li>
</ul>


<p><code>
curl -k -i -X PUT -T "apache-tomcat-6.0.36.tgz" -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile/apache-tomcat-6.0.36.tgz
</code></p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 100 Continue</p>

<p>HTTP/1.1 201 Created
Last-Modified: Tue, 15 Oct 2013 05:39:07 GMT
Content-Length: 0
Etag: 3dde098fd0b3a08d3f2867e4a95591ba
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:39:08 GMT
```</p>

<ul>
<li>列出  Object</li>
</ul>


<p>```</p>

<pre><code>curl -k -i -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile
</code></pre>

<p>```</p>

<p> 如果正确，将会返回以下类似信息：</p>

<p>```
HTTP/1.1 200 OK
Content-Length: 25
X-Container-Object-Count: 1
Accept-Ranges: bytes
X-Timestamp: 1381814521.71796
X-Container-Bytes-Used: 6780936
Content-Type: text/plain; charset=utf-8
Date: Tue, 15 Oct 2013 05:40:43 GMT</p>

<p>apache-tomcat-6.0.36.tgz
```</p>

<p>另外 Object和 Container一样可以通过加参数来限制查询，具体示例可参考 Container操作。</p>

<ul>
<li>下载 Object</li>
</ul>


<p>```</p>

<pre><code>curl -k -X GET -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/myfile/apache-tomcat-6.0.36.tgz &gt; apache-tomcat-6.0.36.tgz
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</p>

<pre><code>                             Dload  Upload   Total   Spent    Left  Speed
</code></pre>

<p>100 6622k  100 6622k    0     0  32.8M      0 &mdash;:&mdash;:&mdash; &mdash;:&mdash;:&mdash; &mdash;:&mdash;:&mdash; 33.1M
```</p>

<ul>
<li>Copy Object</li>
</ul>


<p><code>
curl -k -i -X PUT -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' \
 -H 'X-Copy-From: /myfile/apache-tomcat-6.0.36.tgz' \
 -H 'Content-Length:0' http://192.168.30.150:8080/v1/AUTH_admin/test/apache-tomcat-6.0.36.tgz
</code></p>

<p>将/myfile/apache-tomcat-6.0.36.tgz 拷贝到 /test/apache-tomcat-6.0.36.tgz,如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 201 Created
Content-Length: 0
X-Copied-From-Last-Modified: Tue, 15 Oct 2013 05:39:07 GMT
X-Copied-From: myfile/apache-tomcat-6.0.36.tgz
Last-Modified: Tue, 15 Oct 2013 05:47:52 GMT
Etag: 3dde098fd0b3a08d3f2867e4a95591ba
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:47:52 GMT
</code></p>

<ul>
<li>删除 Object</li>
</ul>


<p>```</p>

<pre><code>curl -k -i -X DELETE -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' http://192.168.30.150:8080/v1/AUTH_admin/test/apache-tomcat-6.0.36.tgz
</code></pre>

<p>```</p>

<p>如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 204 No Content
Content-Length: 0
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:50:49 GMT
</code>
 通过之前的GET就能验证是否成功删除，此处略过。</p>

<ul>
<li>设置 Object Metadata</li>
</ul>


<p><code>
curl -k -i -X POST -H 'X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5' \
-H 'X-Object-Meta-Breed: apache tomcat 6.0.36' \
 http://192.168.30.150:8080/v1/AUTH_admin/myfile/apache-tomcat-6.0.36.tgz
</code></p>

<p>如果正确，将会返回以下类似信息：</p>

<p><code>
HTTP/1.1 202 Accepted
Content-Length: 76
Content-Type: text/html; charset=UTF-8
Date: Tue, 15 Oct 2013 05:54:09 GMT
</code></p>

<p>通过之前的HEAD，就能查看到刚才添加的元数据</p>

<p><code>
HTTP/1.1 200 OK
Content-Length: 6780936
X-Object-Meta-Breed: apache tomcat 6.0.36
Accept-Ranges: bytes
Last-Modified: Tue, 15 Oct 2013 05:54:08 GMT
Etag: 3dde098fd0b3a08d3f2867e4a95591ba
X-Timestamp: 1381816448.74507
Content-Type: application/x-tar
Date: Tue, 15 Oct 2013 05:55:53 GMT
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStack Swift安装与配置]]></title>
    <link href="http://agenge.github.io/blog/2013/10/15/openstack-swift-install/"/>
    <updated>2013-10-15T14:00:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/10/15/openstack-swift-install</id>
    <content type="html"><![CDATA[<h2>准备环境</h2>

<p><code>
192.168.30.150  proxy server
192.168.30.151  storage server
192.168.30.152  storage server
</code></p>

<h2>网络配置</h2>

<p><strong> Proxy 代理节点网络(单网卡)  </strong></p>

<p>```
auto lo
iface lo inet loopback</p>

<h1>The primary network interface</h1>

<p>auto eth0
iface eth0 inet static
address 192.168.30.150
netmask 255.255.255.0
gateway 192.168.30.1
network 192.168.30.0
broadcast 192.168.30.255
dns-nameservers 218.201.4.3
```</p>

<p><strong> 存储节点网络(单网卡)  </strong>
存储节点1：</p>

<p>```
auto lo
iface lo inet loopback</p>

<h1>The primary network interface</h1>

<p>auto eth0
iface eth0 inet static
address 192.168.30.151
netmask 255.255.255.0
gateway 192.168.30.1
network 192.168.30.0
broadcast 192.168.30.255
dns-nameservers 218.201.4.3
```</p>

<p>存储节点2：</p>

<p>```
auto lo
iface lo inet loopback</p>

<h1>The primary network interface</h1>

<p>auto eth0
iface eth0 inet static
address 192.168.30.152
netmask 255.255.255.0
gateway 192.168.30.1
network 192.168.30.0
broadcast 192.168.30.255
dns-nameservers 218.201.4.3
```</p>

<h2>安装公共组件</h2>

<p>以下操作在所有节点全部安装：</p>

<h3>添加源</h3>

<p><code>
cat &gt; /etc/apt/sources.list.d/grizzly.list &lt;&lt; _END_
deb http://ubuntu-cloud.archive.canonical.com/ubuntu precise-updates/grizzly main
deb  http://ubuntu-cloud.archive.canonical.com/ubuntu precise-proposed/grizzly main
_END_
</code></p>

<p>更新源</p>

<p><code>
sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 5EDB1B62EC4926EA
apt-get update
apt-get upgrade
apt-get install ubuntu-cloud-keyring
</code></p>

<!-- more -->


<h2>安装 Swift</h2>

<p><code>
os_swift="python-swift swift swift-proxy swift-account swift-container swift-object python-memcache xfsprogs"
os_keystone="python-keystone python-keystoneclient"
apt-get install -y $os_swift $os_keystone
</code></p>

<p>安装之后需要手工创建 swift相关配置文件:</p>

<p><code>
mkdir /etc/swift
touch /etc/swift/swift.conf
touch /etc/swift/proxy-server.conf
chown -R swift:swift /etc/swift
</code></p>

<p>添加 swift.conf内容：</p>

<p>```
cat > /etc/swift/swift.conf &lt;&lt; <em>END</em>
[swift-hash]</p>

<h1>od -t x8 -N 8 -A n &lt; /dev/random</h1>

<h1>The above command can be used to generate random a string.</h1>

<p>swift_hash_path_suffix = 50ea1ddb6e88b991
<em>END</em>
```</p>

<p>将以下内容添加到 /etc/swift/proxy-server.conf内容：</p>

<p>```
[DEFAULT]
bind_port = 8080
bind_ip = 0.0.0.0
user = swift
swift_dir = /etc/swift</p>

<p>log_facility = LOG_LOCAL0
log_level = DEBUG</p>

<p>[pipeline:main]
pipeline = catch_errors healthcheck cache authtoken keystoneauth container-quotas account-quotas proxy-server</p>

<p>[app:proxy-server]
use = egg:swift#proxy
allow_account_management = true
account_autocreate = true</p>

<p>[filter:keystoneauth]
use = egg:swift#keystoneauth
operator_roles = Member,admin</p>

<p>[filter:authtoken]
paste.filter_factory = keystone.middleware.auth_token:filter_factory
service_protocol = http
service_port = 5000
service_host = 192.168.30.150
auth_port = 35357
auth_host = 192.168.30.150
auth_protocol = http
admin_tenant_name = service
admin_user = swift
admin_password = password
signing_dir = /etc/swift</p>

<p>[filter:cache]
use = egg:swift#memcache
set log_name = cache
memcache_servers = 192.168.30.150:11211</p>

<p>[filter:catch_errors]
use = egg:swift#catch_errors</p>

<p>[filter:healthcheck]
use = egg:swift#healthcheck</p>

<p>[filter:proxy-logging]
use = egg:swift#proxy_logging</p>

<p>[filter:ratelimit]
use = egg:swift#ratelimit
[filter:container-quotas]
use = egg:swift#container_quotas</p>

<p>[filter:account-quotas]
use = egg:swift#account_quotas
```</p>

<p>如果不使用 Keystone 认证，请使用以下的配置文件：</p>

<p>```
[DEFAULT]
bind_port = 8080
bind_ip = 192.168.30.150
user = swift</p>

<p>[pipeline:main]
pipeline = healthcheck cache tempauth proxy-server</p>

<p>[app:proxy-server]
use = egg:swift#proxy
allow_account_management = true
account_autocreate = true</p>

<p>[filter:tempauth]
use = egg:swift#tempauth
user_admin_admin = admin .admin .reseller_admin
user_test_tester = testing .admin
user_test2_tester2 = testing2 .admin
user_test_tester3 = testing3</p>

<p>[filter:healthcheck]
use = egg:swift#healthcheck</p>

<p>[filter:cache]
use = egg:swift#memcache
memcache_servers = 192.168.30.150:11211
```</p>

<p>格式： user<em><login1></em><login2> = <password> <privileges>
登录的时候就是：</p>

<p><code>
login = admin:admin
password = admin
privileges = .admin .reseller_admin
</code></p>

<p>配置rsyslog</p>

<p><code>
echo "local0.*    /var/log/swift/proxy-server.log" &gt;&gt; /etc/rsyslog.conf
mkdir /var/log/swift
</code></p>

<p>配置 环 Ring</p>

<p><code>
cd /etc/swift
sudo swift-ring-builder account.builder create 6 2 1
sudo swift-ring-builder container.builder create 6 2 1
sudo swift-ring-builder object.builder create 6 2 1
</code>
说明</p>

<ul>
<li>第一个数字：6表示分区(环)将被处理为2<sup>6th</sup>，即使用2的6次方个分区，创建完之后应有 64个分区</li>
<li>第二个数字：每个存储对象保存2份，即创建2个副本；由于偶只有两台storage，故只写2</li>
<li>第三个数字：1表示限制分区数据转移的时间，此处表示1小时，即分区被连续移动两次之间的最小时间间隔</li>
</ul>


<p>添加设备
添加新设备到Ring上，但add操作不会分配partitions到新的设备上，只有运行“rebalance”命令后才会进行分区的分配，所以这种方式可以有这种优势： 允许一次添加多个设备，只执行一次rebalance就可以了，以下操作步骤：</p>

<p>```
sudo swift-ring-builder account.builder add z1-192.168.30.151:6002/sdb1 100
sudo swift-ring-builder account.builder add z2-192.168.30.152:6002/sdb1 100</p>

<p>sudo swift-ring-builder container.builder add z1-192.168.30.151:6001/sdb1 100
sudo swift-ring-builder container.builder add z2-192.168.30.152:6001/sdb1 100</p>

<p>sudo swift-ring-builder object.builder add z1-192.168.30.151:6000/sdb1 100
sudo swift-ring-builder object.builder add z2-192.168.30.152:6000/sdb1 100
```</p>

<p>查看 Ring信息
可通过以下命令查到到Ring和Ring中的设备信息：
* 查询account信息：</p>

<pre><code>    swift-ring-builder account.builder
</code></pre>

<ul>
<li><p>查询container信息：</p>

<pre><code>  swift-ring-builder container.builder
</code></pre></li>
<li><p>查询object信息</p>

<pre><code>  swift-ring-builder object.builder
</code></pre></li>
<li><p>生成 Ring
如果确认一切之后，最终还要生成Ring，来进行分区的分配，即之前提到的rebalance：</p></li>
</ul>


<p><code>
sudo swift-ring-builder account.builder rebalance
sudo swift-ring-builder container.builder rebalance
sudo swift-ring-builder object.builder rebalance
</code></p>

<p>设置权限</p>

<p><code>
chown -R swift:swift /etc/swift
chown -R swift:swift /var/cache/swift
</code></p>

<hr />

<h2>存储节点安装与配置</h2>

<p>添加设备：
先创建分区，另外一定要是 XFS文件系统</p>

<p><code>
mkdir -p /srv/node/sdb1
chown -R swift:swift /srv/node/
mkfs.xfs -i size=1024 /dev/sdb1 -f
echo "/dev/sdb1 /srv/node/sdb1 xfs noatime,nodiratime,nobarrier,logbufs=8 0 0" &gt;&gt; /etc/fstab
mount /srv/node/sdb1  
</code></p>

<p>设置 rsyncd.conf</p>

<p>```
uid = swift
gid = swift</p>

<p>log file = /var/log/rsyncd.log
pid file = /var/run/rsyncd.pid
address = 192.168.30.151</p>

<p>[account]
max_connections = 2
path = /srv/node/
read only = false
lock file = /var/lock/account.lock</p>

<p>[container]
max_connections = 2
path = /srv/node/
read only = false
lock file = /var/lock/container.lock</p>

<p>[object]
max_connections = 2
path = /srv/node/
read only = false
lock file = /var/lock/object.lock
```</p>

<p>设置 rsync开机自启动</p>

<pre><code>sudo sed -i 's/RSYNC_ENABLE=false/RSYNC_ENABLE=true/g' /etc/default/rsync
</code></pre>

<p>启动 rsync服务</p>

<pre><code>sudo service rsync start
</code></pre>

<p>创建/etc/account-server.conf：</p>

<p>```
[DEFAULT]
bind_ip = 0.0.0.0
bind_port = 6002
workers = 1
user = swift
swift_dir = /etc/swift
devices = /srv/node</p>

<p>[pipeline:main]
pipeline = account-server</p>

<p>[app:account-server]
use = egg:swift#account</p>

<p>[account-replicator]</p>

<p>[account-auditor]</p>

<p>[account-reaper]</p>

<p>```</p>

<p>创建/etc/container-server.conf</p>

<p>```
[DEFAULT]
bind_ip = 0.0.0.0
bind_port = 6001
workers = 1
user = swift
swift_dir = /etc/swift
devices = /srv/node</p>

<p>[pipeline:main]
pipeline = container-server</p>

<p>[app:container-server]
use = egg:swift#container</p>

<p>[container-replicator]</p>

<p>[container-updater]</p>

<p>[container-auditor]</p>

<p>[container-sync]
```</p>

<p>创建/etc/object-server.conf</p>

<p>```
[DEFAULT]
bind_ip = 0.0.0.0
bind_port = 6000
workers = 1
user = swift
swift_dir = /etc/swift
devices = /srv/node</p>

<p>[pipeline:main]
pipeline = recon object-server</p>

<p>[app:object-server]
use = egg:swift#object</p>

<p>[filter:recon]
use = egg:swift#recon
recon_cache_path = /var/cache/swift</p>

<p>[object-replicator]</p>

<p>[object-updater]</p>

<p>[object-auditor]
```</p>

<h3>重启服务</h3>

<p>在所有存储节点重启以下服务：</p>

<p><code>
sudo swift-init object-server start
sudo swift-init object-replicator start
sudo swift-init object-updater start
sudo swift-init object-auditor start
sudo swift-init container-server start
sudo swift-init container-replicator start
sudo swift-init container-updater start
sudo swift-init container-auditor start
sudo swift-init account-server start
sudo swift-init account-replicator start
sudo swift-init account-auditor start
</code></p>

<p>在代理节点启动以下服务：</p>

<p><code>
sudo swift-init all restart
</code></p>

<h2>Swift操作</h2>

<p>获得 X-Storage-Url 和 X-Auth-Token:</p>

<pre><code>curl -k -v -H 'X-Storage-User: admin:admin' -H 'X-Storage-Pass: admin' http://192.168.30.150:8080/auth/v1.0
</code></pre>

<p>如果正确，将会返回以下类似信息：</p>

<p>```
* About to connect() to 192.168.30.150 port 8080 (#0)
*   Trying 192.168.30.150&hellip; connected</p>

<blockquote><p>GET /auth/v1.0 HTTP/1.1
User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
Host: 192.168.30.150:8080
Accept: <em>/</em>
X-Storage-User: admin:admin
X-Storage-Pass: admin</p>

<p>&lt; HTTP/1.1 200 OK
&lt; X-Storage-Url: <a href="http://192.168.30.150:8080/v1/AUTH_admin">http://192.168.30.150:8080/v1/AUTH_admin</a>
&lt; X-Auth-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Type: text/html; charset=UTF-8
&lt; X-Storage-Token: AUTH_tk8a85916d63b14c568a4633b7920623c5
&lt; Content-Length: 0
&lt; Date: Tue, 15 Oct 2013 01:49:59 GMT
&lt;
* Connection #0 to host 192.168.30.150 left intact
* Closing connection #0
```</p></blockquote>

<p>检查账号</p>

<pre><code>    curl -k -v -H 'X-Auth-Token: &lt;token-from-x-auth-token-above&gt;' &lt;url-from-xstorage-url-above&gt;  
</code></pre>

<p>这里的token-from-x-auth-token-above 就是上面输出的 AUTH_tk8a85916d63b14c568a4633b7920623c5，url-from-xstorage-url-above对应：<a href="http://192.168.30.150:8080/v1/AUTH_admin">http://192.168.30.150:8080/v1/AUTH_admin</a></p>

<p>检测 swift 命令是否工作正常</p>

<pre><code>    swift -A http://192.168.30.150:8080/auth/v1.0 -U admin:admin -K admin stat
</code></pre>

<p>正常输出类似以下信息：</p>

<p>```
   Account: AUTH_admin
Containers: 0
   Objects: 0</p>

<pre><code> Bytes: 0
</code></pre>

<p>Accept-Ranges: bytes
X-Timestamp: 1381806617.24083
Content-Type: text/plain; charset=utf-8
```</p>

<p>上传</p>

<pre><code>swift -A http://192.168.30.150:8080/auth/v1.0 -U admin:admin -K admin upload test apache-tomcat-6.0.36.tar.gz
</code></pre>

<p>删除</p>

<pre><code>swift -A http://192.168.30.150:8080/auth/v1.0 -U admin:admin -K admin delete test apache-tomcat-6.0.36.tar.gz
</code></pre>

<h2>排错思路</h2>

<ol>
<li>直接看控制台打印的日志</li>
<li>检查配置文件是否正确</li>
<li>通过观察日志，例如/var/log/syslog</li>
<li>修改配置文件之后，需要重启对应的服务</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[制作OpenStack Windows Server 2008 镜像]]></title>
    <link href="http://agenge.github.io/blog/2013/07/24/make_openstack-windows2008-image/"/>
    <updated>2013-07-24T00:00:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/07/24/make_openstack-windows2008-image</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>对于OpenStack中，制作一个Windows 的镜像让很多新手极为烦恼，偶有幸成功制作，
不敢私藏，故与大家分享小小心得。上次与大家介绍过 <a href="http://agenge.com/cloud-computing/make_openstack-centos-image.html">制作OpenStack CentOS 6.3 镜像</a></p>

<p>本次主要是记录如何制作一个Windows Server 2008的镜像，请看操作：</p>

<ol>
<li>下载Virtio总线驱动</li>
</ol>


<p> 由于OpenStack只支持Virtio总线的磁盘，所以我们需要在安装之前下载virtio驱动：</p>

<pre><code>    wget http://alt.fedoraproject.org/pub/alt/virtio-win/latest/images/virtio-win-0.1-59.iso
</code></pre>

<ol>
<li>准备一个Windows Server 2008的ISO文件。</li>
</ol>


<p> 除了Virtio总线驱动，您还需要准备一个Windows Server 2008的ISO，为安装操作系统做准备。
3. 创建虚拟磁盘文件：</p>

<pre><code>    qemu-img create -f qcow2 winserver2008.img 20G
</code></pre>

<p> 对于虚拟磁盘文件的各种磁盘格式区别与对比，可以参考 <a href="http://blog.prajnagarden.com/?p=248">qcow2、raw、vmdk等镜像格式</a></p>

<ol>
<li><p>创建虚拟机，使用kvm或virt-install均可，本次安装使用的virt-install</p>

<pre><code> virt-install --connect qemu:///system -n winserver2008 --vcpus=1 -r 2048 \
   --disk path=/path/to/winserver2008.img,size=60,format=qcow2,bus=virtio,cache=none \
   -c /path/iso/windows_server_2008.iso \
   --vnc --vncport=5909 --vnclisten=0.0.0.0  \
   --os-type windows --os-variant=win2k8 --accelerate \
   --network=bridge:br0,model=virtio  \
   --disk path=/path/to/win_driver/virtio-win-0.1-59.iso,device=cdrom,perms=ro&lt;br /&gt;
</code></pre></li>
</ol>


<p> 以上参数有点多，不过这里不一一解释，后期偶会专门写一篇介绍KVM相关知识点，这里只是描述几个重要的参数：</p>

<pre><code>- -n  虚拟机的名称
- --disk  虚拟磁盘存放的路径，即第一步qemu-img创建的虚拟磁盘。&lt;/span&gt;&lt;/li&gt;
- -c  ISO的路径 &lt;/span&gt;&lt;/li&gt;
- --vncport  VNC连接端口，后面会用到，这里是5909，且必须是未使用的端口。&lt;/span&gt;&lt;/li&gt;
- --network   这个地方偶使用的是一个叫 br0 的网桥，所以你的系统必须保证有br0这个网桥。&lt;/span&gt;&lt;/li&gt;
</code></pre>

<!-- more -->


<p></p>

<p> 使用VNC 客户端连接，例如192.168.30.211:9 
 <img src="/images/2013/07/01.png"></p>

<p> 连接成功之后，和常规安装操作系统没有任何区别，但在分区时会提示找到磁盘文件，如图：</p>

<p> <img src="/images/2013/07/02.png"></p>

<p> 点击“<b>加载驱动程序</b>”，并按下图选择对应的驱动：</p>

<p> <img src="/images/2013/07/03.png"></p>

<p> 点击“确定”，如果WIN8驱动找不到磁盘，重新选择WIN7即可。然后再点击“下一步”：</p>

<p> <img src="/images/2013/07/04.png"></p>

<p> 安装之后并关机，进入下一步操作。</p>

<ol>
<li>上传镜像</li>
</ol>


<p> 最后一步就是要将刚才的虚拟磁盘文件上传到云平台中心:</p>

<pre><code>    glance image-create --name Win-2008-x86_64-cloud --is-public true --container-format ovf --disk-format qcow2 &lt; /home/agen/winserver2008.img
</code></pre>

<p> 通过以上的步骤，希望新手能够成功制作一份完美的镜像文件，如果在制作过程中有任何疑问，请留言，最好是邮件，偶在有时间的情况下肯定会第一时间解答。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[制作OpenStack CentOS 6.3 镜像]]></title>
    <link href="http://agenge.github.io/blog/2013/07/20/make_openstack-centos-image/"/>
    <updated>2013-07-20T00:00:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/07/20/make_openstack-centos-image</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>距离上次写文章已经N天，即对不住各位，更对不住自己，今天将教大家如何制作
OpenStack CentOS 6.3 镜像，费话不多说，咱就开始干活吧。</p>

<ol>
<li><p>准备一个镜像文件，即ISO文件，本示例所使用的为：</p>

<pre><code> CentOS-6.3-i386-minimal.iso
</code></pre></li>
</ol>


<p> <em>注：无论您是内部测试环境还是生产环境，偶都强烈推荐使用64位操作系统。</em></p>

<ol>
<li><p>引导并安装系统</p>

<pre><code> virt-install -n CentOS63 -r 2048 --cpu host \
   -c /data/iso/CentOS-6.3-i386-minimal.iso \
   --disk path=/data/kvm_data/centos6.3-openstack.img,device=disk,bus=virtio,size=10,format=qcow2 \
   --vnc --vncport=5908 --vnclisten=0.0.0.0 -v \
   --network bridge=br0
</code></pre></li>
</ol>


<p> 这些参数的就请您先自行查找手册，后期有时间偶会补上关于KVM的相关实践手册。</p>

<ol>
<li>镜像相关设置（此处根据你的需求进行个性化定制，尽量保持简洁）：</li>
<li><p>分区全部给根分区，防火墙和SELinux禁止.</p>

<pre><code>     chkconfig iptables off
</code></pre></li>
</ol>


<p> 将/etc/selinux/config 中的 SELINUX=enforcing修改成 SELINUX=disabled
 * 修改分区表：</p>

<pre><code>        vi /etc/fstab
        # 将UUID=这一行注释，加入：
        LABEL=cec-rootfs                           / ext4 defaults&lt;b&gt; 0 0&lt;/b&gt;
</code></pre>

<ul>
<li><p>修改网络配置：</p>

<pre><code>     vi /etc/sysconfig/network-scripts/ifcfg-eth0
     #将HWADDR=这行删除或注释即可，并且设置成BOOTPROTO=dhcp
</code></pre></li>
<li><p>删除网络规则，因为Centos6之后70-persistent-net.rules这个文件会自动添加除eth0之外的其他网络接口，</p>

<pre><code>     rm -rf /etc/udev/rules.d/70-persistent-net.rules
</code></pre></li>
<li>还要把另外一个文件删除，不然上面这个文件还会自动创建滴：
         mv /lib/udev/write_net_rules{,.bak}</li>
<li><p>上传镜像</p>

<pre><code> glance image-create --name centos63Image --is-public true --container-format ovf --disk-format qcow2 &amp;lt; /home/agen/centos63.img
</code></pre></li>
</ul>


<p> 至此，所有操作已经完成，如果一切正常，你所创建的实例访问正常。如网络还存在问题，可能
和您的OpenStack网络设置有关，不过这已经超出本文的范畴。假如您对OpenStack的环境搭建不是很熟悉的话，建议您再多看看这篇文章：<a title="Openstack安装与部署(Folsom)" href="http://agenge.com/cloud-computing/openstack_install_with_deploy_for_folsom.html">Openstack安装与部署(Folsom)</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack安装与部署(Folsom)]]></title>
    <link href="http://agenge.github.io/blog/2013/06/12/openstack_install_with_deploy_for_folsom/"/>
    <updated>2013-06-12T00:00:00+08:00</updated>
    <id>http://agenge.github.io/blog/2013/06/12/openstack_install_with_deploy_for_folsom</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>近2、3年来，云计算是一个比较热门的话题，无论是国外还是国内，众多计算机厂商开始涉足云计算，未来IaaS、SaaS及PaaS都可能将IT行业又推上到一个新的台阶。云计算谈得最多的IaaS要数 OpenStack，本文主要记录偶试
验的安装步骤，当然，参考了N多网友的博文，具有代表性的可能就是 <a href="http://www.stacklab.org/">stacklab</a> 的安装教程，以下就是具体安装步骤：</p>

<h2>环境准备</h2>

<p> ### 资源列表</p>

<table width="582" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td nowrap="nowrap" width="117">
<p align="center">IP
</td>
<td nowrap="nowrap" width="88">
<p align="center">主机名
</td>
<td nowrap="nowrap" width="87">
<p align="center">OS
</td>
<td nowrap="nowrap" width="70">
<p align="center">CPU
</td>
<td nowrap="nowrap" width="52">
<p align="center">内存
</td>
<td nowrap="nowrap" width="168">
<p align="center">备注
</td>
</tr>
<tr>
<td nowrap="nowrap" width="117">
<p align="center">192.168.30.73
</td>
<td nowrap="nowrap" width="88">
<p align="center">control-01
</td>
<td nowrap="nowrap" width="87">
<p align="center">Ubuntu 12.10
</td>
<td nowrap="nowrap" width="70">
<p align="center">i5
</td>
<td nowrap="nowrap" width="52">
<p align="center">16G
</td>
<td nowrap="nowrap" width="168">
<p align="center">keystone、glance、cinder、nova-api、nova-scheduler
</td>
</tr>
<tr>
<td nowrap="nowrap" width="117">
<p align="center">192.168.30.74
</td>
<td nowrap="nowrap" width="88">
<p align="center">compute-01
</td>
<td nowrap="nowrap" width="87">
<p align="center">Ubuntu 12.10
</td>
<td nowrap="nowrap" width="70">
<p align="center">i5
</td>
<td nowrap="nowrap" width="52">
<p align="center">16G
</td>
<td rowspan="3" nowrap="nowrap" width="168">
<p align="center">nova-compute、nova-network、nova-api-metadata
</td>
</tr>
<tr>
<td nowrap="nowrap" width="117">
<p align="center">192.168.30.75
</td>
<td nowrap="nowrap" width="88">
<p align="center">compute-02
</td>
<td nowrap="nowrap" width="87">
<p align="center">Ubuntu 12.10
</td>
<td nowrap="nowrap" width="70">
<p align="center">i5
</td>
<td nowrap="nowrap" width="52">
<p align="center">16G
</td>
</tr>
<tr>
<td nowrap="nowrap" width="117"></td>
<td nowrap="nowrap" width="88"></td>
<td nowrap="nowrap" width="87"></td>
<td nowrap="nowrap" width="70"></td>
<td nowrap="nowrap" width="52"></td>
</tr>
</tbody>
</table>


<h3>网络配置</h3>

<ol>
<li><p>在配置之前需要注意，如果你的网卡名称有叫非ethX，例如p1p1，就得按以下步骤修改：</p>

<pre><code> cd /etc/udev/rules.d/
 cp 70-persistent-net.rules 70-persistent-net.rules.bak
 ip a
</code></pre>

<p>可看到p1p1的MAC地址，如<strong>d4:3d:7e:57:a4:d4</strong>，将文件70-persistent-net.rules的：
     ATTR{address}==&ldquo;ec:88:8f:ea:c4:eb&rdquo;
修改为：
     ATTR{address}==&ldquo;d4:3d:7e:57:a4:d4&rdquo;</p></li>
</ol>


<p> NAME=&ldquo;eth1&rdquo; 修改为:NAME=&ldquo;eth2&rdquo; 或 NAME=&ldquo;eth0"，只要不和已存在的冲突即可，例如此示例中，本身已经存在一块叫： eth1的网卡，那另外一块就改成eth2。修改之后需要重启服务器。
所有节点配置如下（需要修改每个节点对应的IP）：</p>

<pre><code>    cat /etc/network/interfaces
    # This file describes the network interfaces available on your system
    # and how to activate them. For more information, see interfaces(5).
    # The loopback network interface
    auto lo
    iface lo inet loopback

    # The primary network interface
    auto eth1
    iface eth1 inet static
    address 192.168.30.75
    netmask 255.255.255.0
    network 192.168.30.0
    broadcast 192.168.30.255
    gateway 192.168.30.1
    # dns-* options are implemented by the resolvconf package, if installed
    dns-nameservers 218.201.4.3

    auto eth2
    iface eth2 inet static
    address 10.10.0.75
    netmask 255.255.0.0
</code></pre>

<p> 上面2个IP地址需要根据您的具体情况修改。
2. 重启网络</p>

<pre><code>     /etc/init.d/networking restart
</code></pre>

<ol>
<li><p>IP转发</p>

<pre><code> sudo su -
 sed -i -r 's/^s*#(net.ipv4.ip_forward=1.*)/1/' /etc/sysctl.conf
 echo 1 &gt; /proc/sys/net/ipv4/ip_forward
 sysctl -p
 net.ipv4.ip_forward = 1
</code></pre></li>
<li>更新源</li>
</ol>


<p> 在所有节点的/etc/apt/source.list 加入以下信息：</p>

<pre><code>    deb http://ubuntu-cloud.archive.canonical.com/ubuntu precise-proposed/folsom main
    deb http://ubuntu-cloud.archive.canonical.com/ubuntu precise-updates/folsom main
</code></pre>

<p> 然后执行：</p>

<pre><code>    gpg --keyserver keyserver.ubuntu.com --recv EC4926EA
    gpg --export --armor EC4926EA | sudo apt-key add -
    sudo apt-get update
</code></pre>

<p> 如果报错，请参考<a href="http://blog.csdn.net/wche1990/article/details/6759422">这里</a>.</p>

<!-- more -->


<h3>主机名设置</h3>

<p>在所有节点的/etc/hosts加入以下信息（需要修改每个节点对应的IP）：</p>

<pre><code>    192.168.30.73  control-01
    192.168.30.74  compute-01
    192.168.30.75  compute-02
</code></pre>

<h3>Mysql和rabbitmq安装</h3>

<p>在所有节点执行，密码统一设置为”123456”(你也可以设置为其他较安全的密码)：</p>

<pre><code>    sudo apt-get install -y mysql-server python-mysqldb
    sudo sed -i 's/127.0.0.1/0.0.0.0/g' /etc/mysql/my.cnf
    sudo /etc/init.d/mysql restart
    sudo apt-get install -y rabbitmq-server
</code></pre>

<h3>时间同步</h3>

<p>在所有节点执行：</p>

<pre><code>    sudo apt-get install -y ntp
    sudo sed -i 's/server ntp.ubuntu.com/server ntp.ubuntu.comnserver 127.127.1.0nfudge 127.127.1.0 stratum 10/g' /etc/ntp.conf
    sudo /etc/init.d/ntp restart
</code></pre>

<hr />

<h2>控制节点安装</h2>

<h3>安装OpenStack组件</h3>

<ol>
<li><p>在控制节点执行：</p>

<pre><code> os_keystone="keystone python-keystone python-keystoneclient"
 os_glance="glance glance-api python-glanceclient glance-common"
 os_nova="nova-api nova-cert nova-common  nova-scheduler python-nova python-novaclient nova-consoleauth novnc   nova-novncproxy "
 os_horizon="apache2 libapache2-mod-wsgi openstack-dashboard memcached python-memcache"
 os_cinder="cinder-api cinder-scheduler cinder-volume iscsitarget  open-iscsi iscsitarget-dkms python-cinderclient"
 os_swift="python-swift swift swift-proxy swift-account swift-container swift-object python-memcache"
 sudo apt-get install -y $os_keystone $os_glance $os_nova $os_horizon $os_cinder $os_swift

 大概要下载241M的文件。
</code></pre></li>
</ol>


<h3>初始化数据库</h3>

<ol>
<li><p>在控制节点执行，创建keystone, nova,cinder,glance数据库：</p>

<pre><code> mysql -uroot –p
 mysql&gt; CREATE DATABASE keystone;
 mysql&gt; CREATE DATABASE nova;
 mysql&gt; CREATE DATABASE cinder;
 mysql&gt; CREATE DATABASE glance;
 mysql&gt; GRANT ALL ON keystone.* TO openstack@'%' IDENTIFIED BY 'openstack';
 mysql&gt; GRANT ALL ON nova.* TO openstack@'%' IDENTIFIED BY 'openstack';
 mysql&gt; GRANT ALL ON cinder.* TO openstack@'%' IDENTIFIED BY 'openstack';
 mysql&gt; GRANT ALL ON glance.* TO openstack@'%' IDENTIFIED BY 'openstack';
 mysql&gt; GRANT ALL ON keystone.* TO openstack@'192.168.30.73' IDENTIFIED BY 'openstack';
 mysql&gt; GRANT ALL ON nova.* TO openstack@'192.168.30.73' IDENTIFIED BY 'openstack';
 mysql&gt; GRANT ALL ON nova.* TO openstack@'192.168.30.74' IDENTIFIED BY 'openstack';
 mysql&gt; GRANT ALL ON nova.* TO openstack@'192.168.30.75' IDENTIFIED BY 'openstack';
 mysql&gt; GRANT ALL ON cinder.* TO openstack@'192.168.30.73' IDENTIFIED BY 'openstack';
 mysql&gt; GRANT ALL ON glance.* TO openstack@'192.168.30.73' IDENTIFIED BY 'openstack';
 mysql&gt; flush privileges;
</code></pre></li>
</ol>


<h3>Keystone配置</h3>

<ul>
<li><p>在控制节点修改/etc/keystone/keystone.conf配置文件，注释第57行：</p>

<pre><code>  connection = sqlite:////var/lib/keystone/keystone.db
</code></pre>

<p>加入：</p>

<pre><code>   connection = mysql://openstack:openstack@192.168.30.73/keystone
</code></pre>

<p>重启keystone后，初始化数据库：</p>

<pre><code>   sudo /etc/init.d/keystone restart
   sudo keystone-manage db_sync
</code></pre></li>
<li><p>创建tenant、user、role，脚本keystone_basic.sh内容如下：</p>

<pre><code>     #!/bin/sh
     #
     # Keystone basic configuration

     # Mainly inspired by https://github.com/openstack/keystone/blob/master/tools/sample_data.sh

     # Modified by Bilel Msekni / Institut Telecom
     #
     # Support: openstack@lists.launchpad.net
     # License: Apache Software License (ASL) 2.0
     #
     #节点的IP地址
     HOST_IP=192.168.30.73
     ADMIN_PASSWORD=${ADMIN_PASSWORD:-admin_pass}
     SERVICE_PASSWORD=${SERVICE_PASSWORD:-service_pass}
     export SERVICE_TOKEN="ADMIN"
     export SERVICE_ENDPOINT="http://${HOST_IP}:35357/v2.0"
     SERVICE_TENANT_NAME=${SERVICE_TENANT_NAME:-service}

     get_id () {
         echo `$@ | awk '/ id / { print $4 }'`
     }

     # Tenants
     ADMIN_TENANT=$(get_id keystone tenant-create --name=admin)
     SERVICE_TENANT=$(get_id keystone tenant-create --name=$SERVICE_TENANT_NAME)


     # Users
     ADMIN_USER=$(get_id keystone user-create --name=admin --pass="$ADMIN_PASSWORD" --email=admin@domain.com)


     # Roles
     ADMIN_ROLE=$(get_id keystone role-create --name=admin)
     KEYSTONEADMIN_ROLE=$(get_id keystone role-create --name=KeystoneAdmin)
     KEYSTONESERVICE_ROLE=$(get_id keystone role-create --name=KeystoneServiceAdmin)

     # Add Roles to Users in Tenants
     keystone user-role-add --user-id $ADMIN_USER --role-id $ADMIN_ROLE --tenant-id $ADMIN_TENANT
     keystone user-role-add --user-id $ADMIN_USER --role-id $KEYSTONEADMIN_ROLE --tenant-id $ADMIN_TENANT
     keystone user-role-add --user-id $ADMIN_USER --role-id $KEYSTONESERVICE_ROLE --tenant-id $ADMIN_TENANT

     # The Member role is used by Horizon and Swift
     MEMBER_ROLE=$(get_id keystone role-create --name=Member)

     # Configure service users/roles
     NOVA_USER=$(get_id keystone user-create --name=nova --pass="$SERVICE_PASSWORD" --tenant-id $SERVICE_TENANT --email=nova@domain.com)
     keystone user-role-add --tenant-id $SERVICE_TENANT --user-id $NOVA_USER --role-id $ADMIN_ROLE

     GLANCE_USER=$(get_id keystone user-create --name=glance --pass="$SERVICE_PASSWORD" --tenant-id $SERVICE_TENANT --email=glance@domain.com)
     keystone user-role-add --tenant-id $SERVICE_TENANT --user-id $GLANCE_USER --role-id $ADMIN_ROLE

     CINDER_USER=$(get_id keystone user-create --name=cinder --pass="$SERVICE_PASSWORD" --tenant-id $SERVICE_TENANT --email=cinder@domain.com)
     keystone user-role-add --tenant-id $SERVICE_TENANT --user-id $CINDER_USER --role-id $ADMIN_ROLE
</code></pre></li>
<li><p>创建endpoint，脚本keystone_endpoints_basic.sh内容如下:</p>

<pre><code>     #!/bin/sh
     #
     # Keystone basic Endpoints

     # Mainly inspired by https://github.com/openstack/keystone/blob/master/tools/sample_data.sh

     # Modified by Bilel Msekni / Institut Telecom
     #
     # Support: openstack@lists.launchpad.net
     # License: Apache Software License (ASL) 2.0
     #

     # Host address
     #节点的manage network的IP地址
     HOST_IP=192.168.30.73
     #节点的public network的IP地址
     EXT_HOST_IP=192.168.30.73

     # MySQL definitions
     MYSQL_USER=openstack
     MYSQL_DATABASE=keystone
     MYSQL_HOST=$HOST_IP
     MYSQL_PASSWORD=openstack

     # Keystone definitions
     KEYSTONE_REGION=RegionOne
     export SERVICE_TOKEN=ADMIN
     export SERVICE_ENDPOINT="http://${HOST_IP}:35357/v2.0"

     while getopts "u:D:p:m:K:R:E:T:vh" opt; do
     case $opt in
         u)
           MYSQL_USER=$OPTARG
           ;;
         D)
           MYSQL_DATABASE=$OPTARG
           ;;
         p)
           MYSQL_PASSWORD=$OPTARG
           ;;
         m)
           MYSQL_HOST=$OPTARG
           ;;
         K)
           MASTER=$OPTARG
           ;;
         R)
           KEYSTONE_REGION=$OPTARG
           ;;
         E)
           export SERVICE_ENDPOINT=$OPTARG
           ;;
         T)
           export SERVICE_TOKEN=$OPTARG
           ;;
         v)
           set -x
           ;;
         h)
           cat &lt;&lt;EOF
     Usage: $0 [-m mysql_hostname] [-u mysql_username] [-D mysql_database] [-p mysql_password]
     [-K keystone_master ] [ -R keystone_region ] [ -E keystone_endpoint_url ]
     [ -T keystone_token ]
     Add -v for verbose mode, -h to display this message.
     EOF
           exit 0
           ;;
         \?)
           echo "Unknown option -$OPTARG" &gt;&amp;2
           exit 1
           ;;
         :)
           echo "Option -$OPTARG requires an argument" &gt;&amp;2
           exit 1
           ;;
       esac
     done

     if [ -z "$KEYSTONE_REGION" ]; then
     echo "Keystone region not set. Please set with -R option or set KEYSTONE_REGION variable." &gt;&amp;2
       missing_args="true"
     fi

     if [ -z "$SERVICE_TOKEN" ]; then
     echo "Keystone service token not set. Please set with -T option or set SERVICE_TOKEN variable." &gt;&amp;2
       missing_args="true"
     fi

     if [ -z "$SERVICE_ENDPOINT" ]; then
     echo "Keystone service endpoint not set. Please set with -E option or set SERVICE_ENDPOINT variable." &gt;&amp;2
       missing_args="true"
     fi

     if [ -z "$MYSQL_PASSWORD" ]; then
     echo "MySQL password not set. Please set with -p option or set MYSQL_PASSWORD variable." &gt;&amp;2
       missing_args="true"
     fi

     if [ -n "$missing_args" ]; then
     exit 1
     fi
     keystone service-create --name nova --type compute --description 'OpenStack Compute Service'
     keystone service-create --name cinder --type volume --description 'OpenStack Volume Service'
     keystone service-create --name glance --type image --description 'OpenStack Image Service'
     keystone service-create --name keystone --type identity --description 'OpenStack Identity'
     keystone service-create --name ec2 --type ec2 --description 'OpenStack EC2 service'

     create_endpoint () {
       case $1 in
         compute)
         keystone endpoint-create --region $KEYSTONE_REGION --service-id $2 --publicurl 'http://'"$EXT_HOST_IP"':8774/v2/$(tenant_id)s' --adminurl 'http://'"$HOST_IP"':8774/v2/$(tenant_id)s' --internalurl 'http://'"$HOST_IP"':8774/v2/$(tenant_id)s'
         ;;
         volume)
         keystone endpoint-create --region $KEYSTONE_REGION --service-id $2 --publicurl 'http://'"$EXT_HOST_IP"':8776/v1/$(tenant_id)s' --adminurl 'http://'"$HOST_IP"':8776/v1/$(tenant_id)s' --internalurl 'http://'"$HOST_IP"':8776/v1/$(tenant_id)s'
         ;;
         image)
         keystone endpoint-create --region $KEYSTONE_REGION --service-id $2 --publicurl 'http://'"$EXT_HOST_IP"':9292/v2' --adminurl 'http://'"$HOST_IP"':9292/v2' --internalurl 'http://'"$HOST_IP"':9292/v2'
         ;;
         identity)
         keystone endpoint-create --region $KEYSTONE_REGION --service-id $2 --publicurl 'http://'"$EXT_HOST_IP"':5000/v2.0' --adminurl 'http://'"$HOST_IP"':35357/v2.0' --internalurl 'http://'"$HOST_IP"':5000/v2.0'
         ;;
         ec2)
         keystone endpoint-create --region $KEYSTONE_REGION --service-id $2 --publicurl 'http://'"$EXT_HOST_IP"':8773/services/Cloud' --adminurl 'http://'"$HOST_IP"':8773/services/Admin' --internalurl 'http://'"$HOST_IP"':8773/services/Cloud'
         ;;
       esac
     }

     for i in compute volume image object-store identity ec2; do
     id=`mysql -h "$MYSQL_HOST" -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" "$MYSQL_DATABASE" -ss -e "SELECT id FROM service WHERE type='"$i"';"` || exit 1
       create_endpoint $i $id
     done
</code></pre></li>
<li><p>依次执行：</p>

<pre><code>  sudo chmod +x keystone_*.sh
  sudo ./keystone_basic.sh
  sudo ./keystone_endpoints_basic.sh
</code></pre></li>
<li><p>创建openrc文件（环境变量）</p>

<pre><code>  export OS_TENANT_NAME=admin
  export OS_USERNAME=admin
  export OS_PASSWORD=admin_password
  export OS_AUTH_URL=http://192.168.30.73:5000/v2.0/
  export EC2_URL=$(keystone catalog --service ec2 | awk '/ publicURL / { print $4 }')
  export CREDS=$(keystone ec2-credentials-create)
  export EC2_ACCESS_KEY=$(echo "$CREDS" | awk '/ access / { print $4 }')
  export EC2_SECRET_KEY=$(echo "$CREDS" | awk '/ secret / { print $4 }')
</code></pre></li>
<li><p>使环境变量生效：</p>

<pre><code>  source openrc
</code></pre></li>
<li><p>测试keystone</p>

<pre><code>  keystone user-list
</code></pre></li>
</ul>


<p>如果没问题，输出内容类似下图：</p>

<p><img src="/images/2013/06/01.png" title="" ></p>

<hr />

<h3>Glance配置</h3>

<h4>更新配置文件</h4>

<ol>
<li><p>更新glance配置文件：</p>

<pre><code> sudo vi /etc/glance/glance-api-paste.in
</code></pre></li>
</ol>


<p> 将最后三行修改为：</p>

<pre><code>    [filter:authtoken]
    paste.filter_factory = keystone.middleware.auth_token:filter_factory
    auth_host = 192.168.30.73
    auth_port = 35357
    auth_protocol = http
    admin_tenant_name = service
    admin_user = glance
    admin_password = service_password
</code></pre>

<ol>
<li><p>更新glance配置文件：</p>

<pre><code> sudo vi /etc/glance/glance-registry-paste.ini
</code></pre></li>
</ol>


<p> 将最后三行修改为：</p>

<pre><code>    [filter:authtoken]
    paste.filter_factory = keystone.middleware.auth_token:filter_factory
    auth_host = 192.168.30.73
    auth_port = 35357
    auth_protocol = http
    admin_tenant_name = service
    admin_user = glance
    admin_password = service_password
</code></pre>

<ol>
<li><p>更新glance配置文件：</p>

<pre><code> sudo vim /etc/glance/glance-api.conf
</code></pre>

<p> 将49行注释，并加入：</p>

<pre><code> sql_connection = mysql://openstack:openstack@192.168.30.73/glance
</code></pre>

<p> 在[paste_deploy]（一般在最后几行）节点加入：</p>

<pre><code> flavor = keystone
</code></pre></li>
<li><p>更新glance配置文件：</p>

<pre><code> sudo vim /etc/glance/glance-registry.conf
</code></pre>

<p> 将28行注释，并加入：</p>

<pre><code> sql_connection = mysql://openstack:openstack@192.168.30.73/glance
 [paste_deploy]
 flavor = keystone
</code></pre></li>
<li><p>重启glance服务</p>

<pre><code> /etc/init.d/glance-api restart
 sudo /etc/init.d/glance-registry restart
</code></pre></li>
<li><p>同步数据库</p>

<pre><code> sudo glance-manage db_sync
</code></pre>

<p> 并再次重启glance服务：</p>

<pre><code> sudo /etc/init.d/glance-api restart
 sudo /etc/init.d/glance-registry restart
</code></pre></li>
</ol>


<h4>上传镜像文件</h4>

<pre><code>wget https://launchpad.net/cirros/trunk/0.3.0/+download/cirros-0.3.0-x86_64-disk.img
source openrc
glance image-create --name myFirstVM --is-public true --container-format bare --disk-format qcow2 &amp;lt; cirros-0.3.0-x86_64-disk.img
</code></pre>

<p>如果一切正常，会输出类似以下内容：</p>

<p><img src="/images/2013/06/02.png" title="" ></p>

<hr />

<h3>Cinder配置</h3>

<h4>配置iscsi</h4>

<ol>
<li><p>配置iscsitarget：</p>

<pre><code> sudo sed -i 's/false/true/g' /etc/default/iscsitarget
 sudo /etc/init.d/iscsitarget restart
 sudo /etc/init.d/open-iscsi restart
</code></pre></li>
<li><p>更新配置文件/etc/cinder/api-paste.ini（47行）：</p>

<pre><code> [filter:authtoken]
 paste.filter_factory = keystone.middleware.auth_token:filter_factory
 service_protocol = http
 service_host = 192.168.30.73
 service_port = 5000
 auth_host = 192.168.30.73
 auth_port = 35357
 auth_protocol = http
 admin_tenant_name = service
 admin_user = cinder
 admin_password = service_password
</code></pre></li>
<li><p>更新配置文件/etc/cinder/cinder.conf：</p>

<pre><code> [DEFAULT]
 rootwrap_config = /etc/cinder/rootwrap.conf
 sql_connection = mysql://openstack:openstack@192.168.30.73/cinder
 api_paste_confg = /etc/cinder/api-paste.ini
 iscsi_helper = tgtadm
 volume_name_template = volume-%s
 volume_group = cinder-volumes
 verbose = True
 auth_strategy = keystone
 state_path = /var/lib/cinder
 volumes_dir = /var/lib/cinder/volumes
</code></pre></li>
<li><p>同步数据库：</p>

<pre><code> sudo cinder-manage db sync
</code></pre></li>
</ol>


<h4>创建VG</h4>

<ol>
<li><p>没有独立的硬盘或分区按以下操作：</p>

<p> sudo mkdir -p /opt/data/cinder
 cd /opt/data/cinder
 sudo truncate -s 2G vgfile
 sudo losetup -f &mdash;show vgfile</p></li>
</ol>


<p> 如果正常，会输出以下内容：</p>

<pre><code>    /dev/loop0
</code></pre>

<p> 接下来开始创建vg：</p>

<pre><code>    sudo vgcreate cinder-volumes /dev/loop0
</code></pre>

<p> 如果正常，会输出以下内容：</p>

<pre><code>    No physical volume label read from /dev/loop0
    Writing physical volume data to disk "/dev/loop0"
    Physical volume "/dev/loop0" successfully created
    Volume group "cinder-volumes" successfully created
</code></pre>

<ol>
<li><p>有独立的硬盘或分区按以下操作(<strong>以/dev/sda7</strong><strong>为例，以下操作有数据丢失风险，请谨慎操作</strong>)：</p>

<pre><code> pvcreate /dev/sda7
 vgcreate cinder-volumes /dev/sda7
 lvcreate -L 1T -n instance-lv data-vg
 mkfs.ext4 /dev/data-vg/instance-lv
 echo "/dev/data-vg/instance-lv        /var/lib/nova/instances ext4    defaults        0 0" &gt;&gt; /etc/fstab
 mount -a
</code></pre></li>
</ol>


<p> 重启cinder所有相关服务：</p>

<pre><code>    sudo /etc/init.d/cinder-api restart
    sudo /etc/init.d/cinder-scheduler restart
    sudo /etc/init.d/cinder-volume restart
</code></pre>

<hr />

<h3>Nova配置</h3>

<ol>
<li><p>更新配置文件/etc/nova/api-paste.ini（最后几行）：</p>

<pre><code> [filter:authtoken]
 paste.filter_factory = keystone.middleware.auth_token:filter_factory
 auth_host = 192.168.30.73
 auth_port = 35357
 auth_protocol = http
 admin_tenant_name = service
 admin_user = nova
 admin_password = service_password
 signing_dir = /tmp/keystone-signing-nova
</code></pre></li>
<li><p>更新配置文件/etc/nova/nova.conf</p>

<pre><code> [DEFAULT]
 dhcpbridge_flagfile=/etc/nova/nova.conf
 dhcpbridge=/usr/bin/nova-dhcpbridge
 logdir=/var/log/nova
 state_path=/var/lib/nova
 lock_path=/var/lock/nova
 force_dhcp_release=True
 iscsi_helper=tgtadm
 libvirt_use_virtio_for_bridges=True
 connection_type=libvirt
 root_helper=sudo nova-rootwrap /etc/nova/rootwrap.conf
 verbose=True
 ec2_private_dns_show_ip=True
 api_paste_config=/etc/nova/api-paste.ini
 volumes_path=/var/lib/nova/volumes

 # AUTHENTICATION
 auth_strategy=keystone

 # SCHEDULER
 scheduler_driver=nova.scheduler.multi.MultiScheduler
 compute_scheduler_driver=nova.scheduler.filter_scheduler.FilterScheduler

 # CINDER
 volume_api_class=nova.volume.cinder.API

 # DATABASE
 sql_connection=mysql://openstack:openstack@192.168.30.73/nova

 # COMPUTE
 # kvm or QUME
 libvirt_type=kvm  
 libvirt_use_virtio_for_bridges=True
 start_guests_on_host_boot=True
 resume_guests_state_on_host_boot=True
 api_paste_config=/etc/nova/api-paste.ini
 allow_admin_api=True
 use_deprecated_auth=False
 nova_url=http://192.168.30.73:8774/v1.1/
 root_helper=sudo nova-rootwrap /etc/nova/rootwrap.conf

 # APIS
 ec2_host=192.168.30.73
 ec2_url=http://192.168.30.73:8773/services/Cloud
 keystone_ec2_url=http://192.168.30.73:5000/v2.0/ec2tokens
 s3_host=192.168.30.73
 cc_host=192.168.30.73
 metadata_host=192.168.30.73
 enabled_apis=ec2,osapi_compute,metadata

 # RABBITMQ
 rabbit_host=192.168.30.73

 # GLANCE
 image_service=nova.image.glance.GlanceImageService
 glance_api_servers=192.168.30.73:9292

 # NETWORK
 network_manager=nova.network.manager.FlatDHCPManager
 force_dhcp_release=True
 dhcpbridge_flagfile=/etc/nova/nova.conf
 dhcpbridge=/usr/bin/nova-dhcpbridge
 firewall_driver=nova.virt.libvirt.firewall.IptablesFirewallDriver
 public_interface=eth0    
 flat_interface=eth1     
 flat_network_bridge=br100
 fixed_range=10.10.0.0/24   
 network_size=256
 flat_injected=False
 connection_type=libvirt
 multi_host=True

 # NOVNC CONSOLE
 novnc_enabled=True
 novncproxy_base_url=http://192.168.30.73:6080/vnc_auto.html
 vncserver_proxyclient_address=192.168.30.73
 vncserver_listen=192.168.30.73
</code></pre></li>
<li><p>修改配置文件/etc/sudoers，在最后一行追加：</p>

<pre><code> nova ALL=(ALL) NOPASSWD:ALL
</code></pre></li>
<li><p>同步数据库</p>

<pre><code> sudo nova-manage db sync
</code></pre></li>
<li><p>重启nova相关服务</p>

<pre><code> sudo /etc/init.d/nova-api restart
 sudo /etc/init.d/nova-cert restart
 sudo /etc/init.d/nova-consoleauth restart
 sudo /etc/init.d/nova-novncproxy restart
 sudo /etc/init.d/nova-scheduler restart
</code></pre></li>
<li><p>检查服务状态</p>

<pre><code> sudo nova-manage service list
</code></pre></li>
</ol>


<p> 如果正常，会输出类似以下信息：</p>

<p><img src="/images/2013/06/03.png" title="" ></p>

<ol>
<li><p>创建fixed_ip（内网虚拟机IP）</p>

<pre><code> sudo nova-manage network create private --fixed_range_v4=10.10.0.0/24 --num_networks=1 --bridge=br100 --bridge_interface=eth2 --network_size=256 --multi_host=T
</code></pre></li>
<li><p>创建floating_ip（可以理解为floating_rang，并非一个具体的IP地址），它和公网一个段的IP:</p>

<pre><code> nova-manage floating create 192.168.30.1/24
</code></pre></li>
<li><p>设置安全策略</p>

<pre><code> nova secgroup-add-rule default tcp 1 65535 0.0.0.0/0
 nova secgroup-add-rule default udp 1 65535 0.0.0.0/0
 nova secgroup-add-rule default icmp -1 -1 0.0.0.0/0
</code></pre></li>
</ol>


<hr />

<h2>计算节点安装</h2>

<h3>安装OpenStack组件</h3>

<pre><code>os_nova="nova-common python-nova python-novaclient nova-compute nova-network nova-api-metadata"
os_other="kvm libvirt-bin pm-utils bridge-utils"
sudo apt-get install -y $os_nova $os_other
</code></pre>

<p>大约71M左右。</p>

<h3>Nova配置</h3>

<ol>
<li><p>更新配置文件/etc/nova/nova.conf</p>

<pre><code> [DEFAULT]
 logdir=/var/log/nova
 state_path=/var/lib/nova
 lock_path=/run/lock/nova
 verbose=False
 api_paste_config=/etc/nova/api-paste.ini
 scheduler_driver=nova.scheduler.simple.SimpleScheduler
 s3_host=192.168.30.73
 ec2_host=192.168.30.73
 ec2_dmz_host=192.168.30.73
 rabbit_host=192.168.30.73
 cc_host=192.168.30.73
 metadata_host=10.0.0.7
 nova_url=http://192.168.30.73:8774/v1.1/
 sql_connection=mysql://openstack:openstack@192.168.30.73/nova
 ec2_url=http://192.168.30.73:8773/services/Cloud
 root_helper=sudo nova-rootwrap /etc/nova/rootwrap.conf

 # Auth
 use_deprecated_auth=false
 auth_strategy=keystone
 keystone_ec2_url=http://192.168.30.73:5000/v2.0/ec2tokens
 # Imaging service
 glance_api_servers=192.168.30.73:9292
 image_service=nova.image.glance.GlanceImageService

 # NOVNC CONSOLE
 novnc_enabled=True
 novncproxy_base_url=http://192.168.30.73:6080/vnc_auto.html
 vncserver_proxyclient_address=192.168.30.74
 vncserver_listen=192.168.30.74

 # Network settings
 network_manager=nova.network.manager.FlatDHCPManager
 dhcpbridge_flagfile=/etc/nova/nova.conf
 dhcpbridge=/usr/bin/nova-dhcpbridge
 firewall_driver=nova.virt.libvirt.firewall.IptablesFirewallDriver
 public_interface=eth0
 flat_interface=eth1
 flat_network_bridge=br100
 fixed_range=10.10.0.1/24
 floating_range=192.168.30.128/24
 network_size=250
 flat_network_dhcp_start=10.0.0.40
 flat_injected=false
 force_dhcp_release=true
 dhcp_lease_time=604800
 multi_host=true
 iscsi_helper=tgtadm
 connection_type=libvirt
 # Compute #
 compute_driver=libvirt.LibvirtDriver

 # Cinder #
 volume_api_class=nova.volume.cinder.API
 osapi_volume_listen_port=5900
</code></pre></li>
<li><p>修改配置文件/etc/nova/nova-compute.conf</p>

<pre><code> [DEFAULT]
 libvirt_type=kvm
</code></pre></li>
</ol>


<p> 除了KVM，你还可以修改成其他的，例如QEMU/XEN等。</p>

<ol>
<li><p>禁用默认的网桥</p>

<pre><code> virsh net-autostart default --disable
 virsh net-destroy default
</code></pre></li>
<li><p>重启nova相关服务</p>

<pre><code> sudo /etc/init.d/nova-api-metadata restart
 sudo /etc/init.d/nova-compute restart
 sudo /etc/init.d/nova-network restart
</code></pre></li>
</ol>


<hr />

<h2>访问OpenStack DashBoard</h2>

<p>在控制节点重启httpd和memcached：</p>

<pre><code>sudo /etc/init.d/apache2 restart
sudo /etc/init.d/memcached restart
</code></pre>

<p>访问 <a href="http://192.168.30.73/horizon">http://192.168.30.73/horizon</a>，用户名和密码分别是admin/admin_password</p>

<hr />

<h2>日常管理</h2>

<h3>控制节点管理</h3>

<h4>创建实例</h4>

<h5>创建虚拟机密钥对</h5>

<p>在控制节点执行以下语句：</p>

<pre><code>    root@control-01:~# ssh-keygen 
    Generating public/private rsa key pair.
    Enter file in which to save the key (/root/.ssh/id_rsa): 
    Created directory '/root/.ssh'.
    Enter passphrase (empty for no passphrase): 
    Enter same passphrase again: 
    Your identification has been saved in /root/.ssh/id_rsa.
    Your public key has been saved in /root/.ssh/id_rsa.pub.
    The key fingerprint is:
    6b:6e:2f:b5:b5:73:a6:8e:96:bf:c0:a5:84:7c:c5:92 root@control-01
    The key's randomart image is:
    +--[ RSA 2048]----+
    |                 |
    |           o     |
    |          E o    |
    |       . . o     |
    |        S o .    |
    |         =.o.    |
    |        o.++ .   |
    |       oo +oo o  |
    |       ..+oo=*   |
    +-----------------+
</code></pre>

<h5>导入密钥</h5>

<pre><code>    nova keypair-add --pub_key .ssh/id_rsa.pub key2
    nova keypair-list
    +------+-------------------------------------------------+
    | Name | Fingerprint                                     |
    +------+-------------------------------------------------+
    | key2 | 6b:6e:2f:b5:b5:73:a6:8e:96:bf:c0:a5:84:7c:c5:92 |
    +------+-------------------------------------------------+
</code></pre>

<h5>查看镜像</h5>

<pre><code>    nova image-list
    +--------------------------------------+--------------+--------+--------+
    | ID                                   | Name         | Status | Server |
    +--------------------------------------+--------------+--------+--------+
    | 533457ef-a1fe-41e0-a351-908975d3550b   | myFirstImage   | ACTIVE |        |
    +--------------------------------------+--------------+--------+--------+
</code></pre>

<p>镜像的创建方法请见上传镜像文件。</p>

<h5>查看虚拟机配置模板</h5>

<pre><code>    nova flavor-list
</code></pre>

<h5>创建实例(虚拟机)</h5>

<pre><code>    nova boot --flavor 1 --image 533457ef-a1fe-41e0-a351-908975d3550b --key_name key2 myFirstvm
</code></pre>

<p>创建一个名叫：myFirstvm的实例。</p>

<ul>
<li>&mdash;image             表示使用的哪个镜像文件</li>
<li>&mdash;flavor             使用哪个配置模板，具体见查看虚拟机配置模板</li>
<li>&mdash;key_name       指定密钥文件</li>
</ul>


<p>在创建之后会输出以下类似信息：</p>

<p><img src="/images/2013/06/04.png" title="" ></p>

<p>从图中可看出正在创建一个实例。</p>

<h4>配置网络</h4>

<h5>创建与绑定公网</h5>

<ol>
<li><p>创建一个公网IP，在控制节点执行以下语句：</p>

<pre><code> nova  floating-ip-create
</code></pre></li>
<li><p>创建指定的公网IP</p></li>
</ol>


<p> floating-ip-create只是创建一个随机可用（IP池）的可用公网IP，那如何要创建一个指定的IP如何操作？没关系，nova可以做到，请看操作：</p>

<pre><code>    nova add-floating-ip test01 192.168.30.6
</code></pre>

<ol>
<li><p>绑定公网IP地址到虚拟机</p>

<pre><code> nova add-floating-ip vm01 192.168.30.1
</code></pre></li>
</ol>


<p> 表示绑定到vm01这个虚拟机。可通过查看虚拟机状态看到：</p>

<pre><code>    nova show vm01
</code></pre>

<h5>防火墙设置</h5>

<ol>
<li><p>允许SSH登录</p>

<pre><code> nova secgroup-add-rule default tcp 22 22 0.0.0.0/0
</code></pre></li>
<li><p>允许ICMP Ping</p>

<pre><code> nova secgroup-add-rule default icmp -1 -1 0.0.0.0/0
</code></pre></li>
<li><p>查看防火墙设置</p>

<pre><code> nova secgroup-list-rules default
</code></pre></li>
</ol>


<h5>删除或解绑floating-ip</h5>

<p>如果某个公网IP不再需要，你可以通过删除或解绑它：</p>

<pre><code>    nova remove-floating-ip test01 192.168.30.6
</code></pre>

<p>或</p>

<pre><code>    nova floating-ip-delete test01 192.168.30.6
</code></pre>

<p>删除之后就会从IP池释放出来，以供其他Tenant使用。</p>

<hr />

<h3>Cinder管理</h3>

<ol>
<li><p>列出当前用户所有资源</p>

<pre><code> cinder absolute-limits
</code></pre></li>
<li><p>创建一个Volume</p>

<pre><code> cinder create --display_name cin01 10
</code></pre></li>
<li><p>&mdash;display_name为volume名称，后面的数字表示为10G。</p></li>
<li><p>查看Volume</p>

<pre><code> cinder list
</code></pre></li>
</ol>


<p> 或者</p>

<pre><code>    nova volume-list
</code></pre>

<hr />

<h3>计算节点管理</h3>

<h4>KVM驱动</h4>

<p>要启用KVM，只需要在/etc/nova/nova.conf加入：</p>

<pre><code>    libvirt_type=kvm
    compute_driver=libvirt.LibvirtDriver
</code></pre>

<p>KVM支持的虚拟机镜像格式：RAW、QCOW2、VMDK</p>

<h4>QEMU驱动</h4>

<p>要启用QEMU，只需要在/etc/nova/nova.conf加入：</p>

<pre><code>    libvirt_type=qemu
    compute_driver=libvirt.LibvirtDriver
</code></pre>

<p>QEMU支持的虚拟机镜像格式：RAW、QCOW2、VMDK</p>

<h4>Xen驱动</h4>

<p>要启用Xen，包括Xen, XenAPI, XenServer and XCP，只需要在/etc/nova/nova.conf加入：</p>

<pre><code>    compute_driver=xenapi.XenAPIDriver
    xenapi_connection_url=http://your_xenapi_management_ip_address
    xenapi_connection_username=root
    xenapi_connection_password=your_password
</code></pre>

<p>XenAPI支持的虚拟机镜像格式：RAW、VHD</p>

<p>如果您的Xen使用的libvirt管理，只需要在/etc/nova/nova.conf加入：</p>

<pre><code>    libvirt_type=xen
    compute_driver=libvirt.LibvirtDriver
</code></pre>

<hr />

<h3>Glance管理</h3>

<h4>磁盘格式</h4>

<ul>
<li><p>raw 此格式支持兼容转换其他格式文件，类似于中间格式，最大的缺点是<strong>不支持虚拟机的快照功能</strong>，使用空间类似于物理磁盘，使用多少空间实际上就是多少空间，可以通过du -h file.raw 来查看它真正的大小，而ls -lh看到的就是整个raw文件大小（包括剩余空间）</p></li>
<li><p>qcow2 更小的存储空间，du -h 和ls -h看到的大小一样。且支持虚拟机的快照功能，性能接近于 raw 格式的文件。支持AES加密、zlib压缩。</p></li>
<li><p>vhd 微软的虚拟磁盘文件，不过也兼容其他虚拟软件。</p></li>
<li><p>vmdk VMware的专有格式，其在自身的虚拟环境中，无论从性能还是功能，都是最强大、最稳定的，其他虚拟化软件较少用到。</p></li>
<li><p>iso 经典的ISO文件，不多介绍。</p></li>
<li><p>vdi VirtualBox的专有格式，一般服务器虚拟化也很少用到。</p></li>
<li><p>aki Amazon内核镜像文件。</p></li>
<li><p>ari Amazon 内存（ramdisk）镜像文件。</p></li>
<li><p>ami Amazon机器镜像文件。</p></li>
</ul>


<h4>容器格式</h4>

<p>Glance的container format主要包括以下格式：</p>

<ul>
<li><p>bare                  表示镜像没有包括container或元数据，如果不知道选哪个格式，就选bare吧。</p></li>
<li><p>ovf                   开放式虚拟磁盘文件，最初由VMware发起，支持多种虚拟化。</p></li>
<li><p>aki                    Amazon内核镜像文件，在 磁盘格式设置为 aki 时使用。</p></li>
<li><p>ari                    Amazon 内存（ramdisk）镜像文件，在 磁盘格式设置为 ari 时使用。</p></li>
<li><p>ami                   Amazon机器镜像文件，在 磁盘格式设置为 ami 时使用。</p></li>
</ul>


<p>关于安装与部署，偶暂时写到这里，这只是很简单的一个入门例子而已，下次偶会介绍
如何制作CentOS5.5、CentOS 6.3及Windows Server 2008的镜像，很多同学因镜像而烦恼。</p>
]]></content>
  </entry>
  
</feed>
